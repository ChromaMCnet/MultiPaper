From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Sat, 25 May 2024 12:05:30 +0900
Subject: [PATCH] Teleportation


diff --git a/src/main/java/net/minecraft/server/commands/TeleportCommand.java b/src/main/java/net/minecraft/server/commands/TeleportCommand.java
index 54851f6cc0d5fddb32a9a1e84a4f5ae41af18758..54d88d05bded806ab4c5f612f244e99d99b07fc2 100644
--- a/src/main/java/net/minecraft/server/commands/TeleportCommand.java
+++ b/src/main/java/net/minecraft/server/commands/TeleportCommand.java
@@ -12,7 +12,10 @@ import java.util.EnumSet;
 import java.util.Iterator;
 import java.util.Locale;
 import java.util.Set;
+import java.util.concurrent.CompletableFuture;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.util.TickThread;
 import net.minecraft.commands.CommandSourceStack;
 import net.minecraft.commands.arguments.EntityAnchorArgument;
 import net.minecraft.commands.arguments.EntityArgument;
@@ -29,6 +32,7 @@ import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.LivingEntity;
 import net.minecraft.world.entity.PathfinderMob;
 import net.minecraft.world.entity.RelativeMovement;
+import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.phys.Vec2;
 import net.minecraft.world.phys.Vec3;
@@ -37,6 +41,8 @@ import org.bukkit.Location;
 import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.event.entity.EntityTeleportEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
+import puregero.multipaper.region.RegionPos;
+import puregero.multipaper.threading.MultiPaperRegionScheduler;
 // CraftBukkit end
 
 public class TeleportCommand {
@@ -162,9 +168,19 @@ public class TeleportCommand {
             float f3 = Mth.wrapDegrees(pitch);
 
             // CraftBukkit start - Teleport event
-            boolean result;
+            // MultiPaper start - Run teleports on the correct thread
+            CompletableFuture<Boolean> result = new CompletableFuture<>();
             if (target instanceof ServerPlayer player) {
-                result = player.teleportTo(world, x, y, z, movementFlags, f2, f3, PlayerTeleportEvent.TeleportCause.COMMAND);
+                ChunkPos toPos = new ChunkPos(new BlockPos((int) x, (int) y, (int) z));
+                Runnable task = () -> {
+                    result.complete(player.teleportTo(world, x, y, z, movementFlags, f2, f3, PlayerTeleportEvent.TeleportCause.COMMAND));
+                };
+                if (TickThread.isTickThreadFor(target) && TickThread.isTickThreadFor(world, toPos)) {
+                    task.run();
+                } else {
+                    MultiPaperRegionScheduler.scheduleAcrossLevels((ServerLevel) target.level(), RegionPos.forChunk(target.chunkPosition()), world, RegionPos.forChunk(toPos), task);
+                }
+                // MultiPaper end - Run teleports on the correct thread
             } else {
                 Location to = new Location(world.getWorld(), x, y, z, f2, f3);
                 EntityTeleportEvent event = new EntityTeleportEvent(target.getBukkitEntity(), target.getBukkitEntity().getLocation(), to);
@@ -174,17 +190,29 @@ public class TeleportCommand {
                 }
                 to = event.getTo(); // Paper - actually track new location
 
-                x = to.getX();
-                y = to.getY();
-                z = to.getZ();
-                f2 = to.getYaw();
-                f3 = to.getPitch();
-                world = ((CraftWorld) to.getWorld()).getHandle();
-
-                result = target.teleportTo(world, x, y, z, movementFlags, f2, f3);
+                // MultiPaper start - Run teleports on the correct thread
+                double finalX = to.getX();
+                double finalY = to.getY();
+                double finalZ = to.getZ();
+                float finalF2 = to.getYaw();
+                float finalF3 = to.getPitch();
+                ServerLevel finalWorld = ((CraftWorld) to.getWorld()).getHandle();
+
+                ChunkPos toPos = new ChunkPos(new BlockPos((int) finalX, (int) finalY, (int) finalZ));
+                Runnable task = () -> {
+                    result.complete(target.teleportTo(finalWorld, finalX, finalY, finalZ, movementFlags, finalF2, finalF3));
+                };
+                if (TickThread.isTickThreadFor(target) && TickThread.isTickThreadFor(finalWorld, toPos)) {
+                    task.run();
+                } else {
+                    MultiPaperRegionScheduler.scheduleAcrossLevels((ServerLevel) target.level(), RegionPos.forChunk(target.chunkPosition()), finalWorld, RegionPos.forChunk(toPos), task);
+                }
+                // MultiPaper end - Run teleports on the correct thread
             }
 
-            if (result) {
+            result.thenAccept(success -> { // MultiPaper
+                if (!success) return; // MultiPaper
+
                 // CraftBukkit end
                 if (facingLocation != null) {
                     facingLocation.perform(source, target);
@@ -209,8 +237,7 @@ public class TeleportCommand {
 
                     entitycreature.getNavigation().stop();
                 }
-
-            }
+            }); // MultiPaper
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 162087bd74f53dce7eef9efa7e85c83538db23a7..ff841b91a4c3f41bc39781339dbf639a720464dd 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -2170,6 +2170,8 @@ public class ServerPlayer extends Player {
     }
 
     public boolean teleportTo(ServerLevel worldserver, double d0, double d1, double d2, Set<RelativeMovement> set, float f, float f1, TeleportCause cause) {
+        TickThread.ensureTickThread(this, "Cannot teleport player async"); // MultiPaper
+        TickThread.ensureTickThread(worldserver, d0, d2, "Cannot teleport player to async destination"); // MultiPaper
         // CraftBukkit end
         ChunkPos chunkcoordintpair = new ChunkPos(BlockPos.containing(d0, d1, d2));
 
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 94a7194de023208917e29e22b7d5fd9e8d90846c..8f237d9f3ee31304146f602bf9c382daabf9fc48 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -2981,19 +2981,27 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         switch (packetplayinclientcommand_enumclientcommand) {
             case PERFORM_RESPAWN:
                 if (this.player.wonGame) {
-                    this.player.wonGame = false;
-                    this.player = this.server.getPlayerList().respawn(this.player, this.server.getLevel(this.player.getRespawnDimension()), true, null, true, RespawnReason.END_PORTAL, org.bukkit.event.player.PlayerRespawnEvent.RespawnFlag.END_PORTAL); // Paper - Expand PlayerRespawnEvent
-                    CriteriaTriggers.CHANGED_DIMENSION.trigger(this.player, Level.END, Level.OVERWORLD);
+                    // MultiPaper start - async respawn
+                    this.server.getPlayerList().respawnAsync(this.player, this.server.getLevel(this.player.getRespawnDimension()), true, null, true, RespawnReason.END_PORTAL, org.bukkit.event.player.PlayerRespawnEvent.RespawnFlag.END_PORTAL).thenAccept(player -> { // Paper - Expand PlayerRespawnEvent
+                        this.player.wonGame = false;
+                        this.player = player;
+                        CriteriaTriggers.CHANGED_DIMENSION.trigger(this.player, Level.END, Level.OVERWORLD);
+                    });
+                    // MultiPaper end - async respawn
                 } else {
                     if (this.player.getHealth() > 0.0F) {
                         return;
                     }
 
-                    this.player = this.server.getPlayerList().respawn(this.player, false, RespawnReason.DEATH);
-                    if (this.server.isHardcore()) {
-                        this.player.setGameMode(GameType.SPECTATOR, org.bukkit.event.player.PlayerGameModeChangeEvent.Cause.HARDCORE_DEATH, null); // Paper - Expand PlayerGameModeChangeEvent
-                        ((GameRules.BooleanValue) this.player.level().getGameRules().getRule(GameRules.RULE_SPECTATORSGENERATECHUNKS)).set(false, this.player.serverLevel()); // CraftBukkit - per-world
-                    }
+                    // MultiPaper start - async respawn
+                    this.server.getPlayerList().respawnAsync(this.player, false, RespawnReason.DEATH).thenAccept(player -> {
+                        this.player = player;
+                        if (this.server.isHardcore()) {
+                            this.player.setGameMode(GameType.SPECTATOR, org.bukkit.event.player.PlayerGameModeChangeEvent.Cause.HARDCORE_DEATH, null); // Paper - Expand PlayerGameModeChangeEvent
+                            ((GameRules.BooleanValue) this.player.level().getGameRules().getRule(GameRules.RULE_SPECTATORSGENERATECHUNKS)).set(false, this.player.serverLevel()); // CraftBukkit - per-world
+                        }
+                    });
+                    // MultiPaper end - async respawn
                 }
                 break;
             case REQUEST_STATS:
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index e8d6a2b1a0870da97e3a004486ad94a725d313a5..7186515bb246261d04a62c4cd0c939b7a19e4da9 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -22,9 +22,13 @@ import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
 import java.util.function.Function;
 import java.util.function.Predicate;
+import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.util.TickThread;
 import net.minecraft.ChatFormatting;
 import net.minecraft.FileUtil;
 import net.minecraft.commands.CommandSourceStack;
@@ -88,6 +92,7 @@ import net.minecraft.util.Mth;
 import net.minecraft.world.effect.MobEffectInstance;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.GameRules;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.Blocks;
@@ -123,6 +128,8 @@ import org.bukkit.event.player.PlayerRespawnEvent;
 import org.bukkit.event.player.PlayerRespawnEvent.RespawnReason;
 import org.bukkit.event.player.PlayerSpawnChangeEvent;
 import puregero.multipaper.MultiPaper;
+import puregero.multipaper.region.RegionPos;
+import puregero.multipaper.threading.MultiPaperRegionScheduler;
 // CraftBukkit end
 
 public abstract class PlayerList {
@@ -837,12 +844,52 @@ public abstract class PlayerList {
     }
 
     public ServerPlayer respawn(ServerPlayer entityplayer, ServerLevel worldserver, boolean flag, Location location, boolean avoidSuffocation, RespawnReason reason, org.bukkit.event.player.PlayerRespawnEvent.RespawnFlag...respawnFlags) {
+        // MultiPaper start - async respawn
+        throw new UnsupportedOperationException("Cannot respawn player synchronously");
+    }
+
+    public CompletableFuture<ServerPlayer> respawnAsync(ServerPlayer entityplayer, boolean flag, RespawnReason reason) {
+        return this.respawnAsync(entityplayer, this.server.getLevel(entityplayer.getRespawnDimension()), flag, null, true, reason);
+    }
+
+    @Nullable private CompletableFuture<ServerPlayer> currentRespawnFuture = null;
+    public CompletableFuture<ServerPlayer> respawnAsync(ServerPlayer entityplayer, ServerLevel worldserver, boolean flag, Location location, boolean avoidSuffocation, RespawnReason reason, org.bukkit.event.player.PlayerRespawnEvent.RespawnFlag...respawnFlags) {
+        if (currentRespawnFuture != null && !currentRespawnFuture.isDone()) {
+            throw new IllegalStateException("An async respawn is already in progress!");
+        }
+        CompletableFuture<ServerPlayer> future = currentRespawnFuture = new CompletableFuture<>();
+        // MultiPaper end - async respawn
         // Paper end - Expand PlayerRespawnEvent
         entityplayer.stopRiding(); // CraftBukkit
-        this.players.remove(entityplayer);
-        this.playersByName.remove(entityplayer.getScoreboardName().toLowerCase(java.util.Locale.ROOT)); // Spigot
-        entityplayer.serverLevel().removePlayerImmediately(entityplayer, Entity.RemovalReason.DISCARDED);
+        // this.players.remove(entityplayer); // MultiPaper - don't do this, we're reusing the same entity
+        // this.playersByName.remove(entityplayer.getScoreboardName().toLowerCase(java.util.Locale.ROOT)); // Spigot // MultiPaper - don't do this, we're reusing the same entity
+        // entityplayer.serverLevel().removePlayerImmediately(entityplayer, Entity.RemovalReason.DISCARDED); // MultiPaper - do later
         BlockPos blockposition = entityplayer.getRespawnPosition();
+
+        // MultiPaper start - run on respawn position thread
+        Runnable task = () -> respawnAsyncGetRespawnPosition(future, entityplayer, blockposition, worldserver, flag, location, avoidSuffocation, reason, respawnFlags);
+
+        ServerLevel fromLevel = entityplayer.serverLevel();
+        ChunkPos fromPos = entityplayer.chunkPosition();
+        ServerLevel toLevel = this.server.getLevel(entityplayer.getRespawnDimension());
+        BlockPos toPos = blockposition;
+
+        if (toLevel == null || toPos == null) {
+            toLevel = this.server.getLevel(Level.OVERWORLD);
+            toPos = toLevel.getSharedSpawnPos();
+        }
+
+        if (TickThread.isTickThreadFor(fromLevel, fromPos) && TickThread.isTickThreadFor(toLevel, toPos)) {
+            task.run();
+        } else {
+            MultiPaperRegionScheduler.scheduleAcrossLevels(fromLevel, RegionPos.forChunk(fromPos), toLevel, RegionPos.forChunk(new ChunkPos(toPos)), task);
+        }
+
+        return future;
+    }
+    private void respawnAsyncGetRespawnPosition(CompletableFuture<ServerPlayer> future, ServerPlayer entityplayer, BlockPos blockposition, ServerLevel worldserver, boolean flag, Location location, boolean avoidSuffocation, RespawnReason reason, org.bukkit.event.player.PlayerRespawnEvent.RespawnFlag...respawnFlags) {
+        // MultiPaper end - run on respawn position thread
+
         float f = entityplayer.getRespawnAngle();
         boolean flag1 = entityplayer.isRespawnForced();
         /* CraftBukkit start
@@ -863,17 +910,19 @@ public abstract class PlayerList {
         entityplayer.wonGame = false;
         // CraftBukkit end
 
-        entityplayer1.connection = entityplayer.connection;
-        entityplayer1.restoreFrom(entityplayer, flag);
-        entityplayer1.setId(entityplayer.getId());
-        entityplayer1.setMainArm(entityplayer.getMainArm());
-        Iterator iterator = entityplayer.getTags().iterator();
+        // MultiPaper start - it's the same entity, just skip the copy process rather than figuring out how to rearrange it
+        // entityplayer1.connection = entityplayer.connection;
+        // entityplayer1.restoreFrom(entityplayer, flag);
+        // entityplayer1.setId(entityplayer.getId());
+        // entityplayer1.setMainArm(entityplayer.getMainArm());
+        // Iterator iterator = entityplayer.getTags().iterator();
 
-        while (iterator.hasNext()) {
-            String s = (String) iterator.next();
+        // while (iterator.hasNext()) {
+        //     String s = (String) iterator.next();
 
-            entityplayer1.addTag(s);
-        }
+        //     entityplayer1.addTag(s);
+        // }
+        // MultiPaper end - it's the same entity, just skip the copy process rather than figuring out how to rearrange it
 
         boolean flag2 = false;
 
@@ -933,7 +982,7 @@ public abstract class PlayerList {
             this.cserver.getPluginManager().callEvent(respawnEvent);
             // Spigot Start
             if (entityplayer.connection.isDisconnected()) {
-                return entityplayer;
+                future.complete(entityplayer); return; // return entityplayer; // MultiPaper
             }
             // Spigot End
 
@@ -948,6 +997,32 @@ public abstract class PlayerList {
         } else {
             location.setWorld(worldserver.getWorld());
         }
+
+        // MultiPaper start - run on new respawn position thread, in case a plugin modified it
+        BlockPos finalBlockposition = blockposition;
+        Location finalLocation = location;
+        boolean finalIsLocAltered = isLocAltered;
+        boolean finalFlag = flag2;
+        boolean finalIsRespawn = isRespawn;
+        boolean finalIsBedSpawn = isBedSpawn;
+        Runnable task = () -> respawnAsyncFinal(future, entityplayer, finalBlockposition, flag, finalLocation, avoidSuffocation, finalIsLocAltered, flag1, finalFlag, fromWorld, finalIsRespawn, finalIsBedSpawn);
+
+        ServerLevel fromLevel = entityplayer.serverLevel();
+        ChunkPos fromPos = entityplayer.chunkPosition();
+        ServerLevel toLevel = ((CraftWorld) location.getWorld()).getHandle();
+        BlockPos toPos = new BlockPos(location.getBlockX(), location.getBlockY(), location.getBlockZ());
+
+        if (TickThread.isTickThreadFor(fromLevel, fromPos) && TickThread.isTickThreadFor(toLevel, toPos)) {
+            task.run();
+        } else {
+            MultiPaperRegionScheduler.scheduleAcrossLevels(fromLevel, RegionPos.forChunk(fromPos), toLevel, RegionPos.forChunk(new ChunkPos(toPos)), task);
+        }
+    }
+    private void respawnAsyncFinal(CompletableFuture<ServerPlayer> future, ServerPlayer entityplayer1, BlockPos blockposition, boolean flag, Location location, boolean avoidSuffocation, boolean isLocAltered, boolean flag1, boolean flag2, org.bukkit.World fromWorld, boolean isRespawn, boolean isBedSpawn) {
+        ServerPlayer entityplayer = entityplayer1;
+        entityplayer.serverLevel().removePlayerImmediately(entityplayer, Entity.RemovalReason.DISCARDED);
+        // MultiPaper end - run on respawn position thread
+
         ServerLevel worldserver1 = ((CraftWorld) location.getWorld()).getHandle();
         entityplayer1.spawnIn(worldserver1);
         entityplayer1.unsetRemoved();
@@ -975,9 +1050,9 @@ public abstract class PlayerList {
         this.sendPlayerPermissionLevel(entityplayer1);
         if (!entityplayer.connection.isDisconnected()) {
             worldserver1.addRespawnedPlayer(entityplayer1);
-            this.players.add(entityplayer1);
-            this.playersByName.put(entityplayer1.getScoreboardName().toLowerCase(java.util.Locale.ROOT), entityplayer1); // Spigot
-            this.playersByUUID.put(entityplayer1.getUUID(), entityplayer1);
+            // this.players.add(entityplayer1); // MultiPaper - don't do this, we're reusing the same entity
+            // this.playersByName.put(entityplayer1.getScoreboardName().toLowerCase(java.util.Locale.ROOT), entityplayer1); // Spigot // MultiPaper - don't do this, we're reusing the same entity
+            // this.playersByUUID.put(entityplayer1.getUUID(), entityplayer1); // MultiPaper - don't do this, we're reusing the same entity
         }
         // entityplayer1.initInventoryMenu();
         entityplayer1.setHealth(entityplayer1.getHealth());
@@ -1018,7 +1093,7 @@ public abstract class PlayerList {
         // Paper end - Add PlayerPostRespawnEvent
 
         // CraftBukkit end
-        return entityplayer1;
+        future.complete(entityplayer1); // return entityplayer1; // MultiPaper
     }
 
     public void sendPlayerPermissionLevel(ServerPlayer player) {
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 852613327dd20d1758612ec1026772b4e556d3de..bf3b25db00d62d1cafc9ba1921553bdf6a4b5bab 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -6,6 +6,7 @@ import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import com.google.common.collect.UnmodifiableIterator;
 import com.mojang.logging.LogUtils;
+import io.papermc.paper.util.TickThread;
 import it.unimi.dsi.fastutil.objects.Object2DoubleArrayMap;
 import it.unimi.dsi.fastutil.objects.Object2DoubleMap;
 import java.util.Arrays;
@@ -109,6 +110,7 @@ import net.minecraft.world.level.dimension.DimensionType;
 import net.minecraft.world.level.dimension.LevelStem;
 import net.minecraft.world.level.entity.EntityAccess;
 import net.minecraft.world.level.entity.EntityInLevelCallback;
+import net.minecraft.world.level.entity.LevelCallback;
 import net.minecraft.world.level.gameevent.DynamicGameEventListener;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.levelgen.Heightmap;
@@ -2140,6 +2142,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
 
     public void moveTo(double x, double y, double z, float yaw, float pitch) {
+        if (levelCallback != EntityInLevelCallback.NULL) TickThread.ensureTickThread((ServerLevel) level(), position.x, position.z, "Can't move entity to async destination"); // MultiPaper - can't teleport into other regions
         // Paper start - Fix Entity Teleportation and cancel velocity if teleported
         if (!preserveMotion) {
             this.deltaMovement = Vec3.ZERO;
@@ -3797,6 +3800,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
                     this.setDeltaMovement(shapedetectorshape.speed);
                     return this;
                 }
+                TickThread.ensureTickThread(worldserver, position.x, position.z, "Can't teleport entity to async destination"); // MultiPaper - can't teleport into other regions
                 this.unRide();
                 // CraftBukkit end
 
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index aef9a80b3beffc0fe6dbfac9b24989a80e98c25d..5afc547b41ab33c1ae22a362b8e1092958c9f221 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -5,6 +5,7 @@ import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.mojang.datafixers.util.Pair;
+import io.papermc.paper.util.TickThread;
 import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
@@ -2537,7 +2538,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     // Paper start
     public java.util.concurrent.CompletableFuture<Chunk> getChunkAtAsync(int x, int z, boolean gen, boolean urgent) {
         warnUnsafeChunk("getting a faraway chunk async", x, z); // Paper
-        if (Bukkit.isPrimaryThread()) {
+        if (TickThread.isTickThreadFor(getHandle(), x, z)) { // MultiPaper - ensure it's the chunk's thread
             net.minecraft.world.level.chunk.LevelChunk immediate = this.world.getChunkSource().getChunkAtIfLoadedImmediately(x, z);
             if (immediate != null) {
                 return java.util.concurrent.CompletableFuture.completedFuture(new CraftChunk(immediate));
@@ -2554,11 +2555,11 @@ public class CraftWorld extends CraftRegionAccessor implements World {
         java.util.concurrent.CompletableFuture<Chunk> ret = new java.util.concurrent.CompletableFuture<>();
 
         io.papermc.paper.chunk.system.ChunkSystem.scheduleChunkLoad(this.getHandle(), x, z, gen, ChunkStatus.FULL, true, priority, (c) -> {
-            net.minecraft.server.MinecraftServer.getServer().scheduleOnMain(() -> {
+            // net.minecraft.server.MinecraftServer.getServer().scheduleOnMain(() -> { // MultiPaper - this is already on the main thread
                 net.minecraft.world.level.chunk.LevelChunk chunk = (net.minecraft.world.level.chunk.LevelChunk)c;
                 if (chunk != null) this.addTicket(x, z); // Paper
                 ret.complete(chunk == null ? null : new CraftChunk(chunk));
-            });
+            // }); // MultiPaper - this is already on the main thread
         });
 
         return ret;
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index 0ed18542fd8e2a992dc56a5f421eaa840e0af193..9fc8cb99b575e9e3f037de22bc8a03b29317e4cc 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -8,6 +8,9 @@ import com.google.common.collect.Lists;
 import java.util.List;
 import java.util.Set;
 import java.util.UUID;
+
+import io.papermc.paper.util.TickThread;
+import net.minecraft.core.BlockPos;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.Tag;
 import net.minecraft.network.chat.Component;
@@ -19,6 +22,7 @@ import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.boss.EnderDragonPart;
 import net.minecraft.world.entity.boss.enderdragon.EnderDragon;
 import net.minecraft.world.entity.projectile.AbstractArrow;
+import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.phys.AABB;
 import org.bukkit.EntityEffect;
 import org.bukkit.Location;
@@ -57,6 +61,8 @@ import org.bukkit.util.NumberConversions;
 import org.bukkit.util.Vector;
 
 import net.md_5.bungee.api.chat.BaseComponent; // Spigot
+import puregero.multipaper.region.RegionPos;
+import puregero.multipaper.threading.MultiPaperRegionScheduler;
 
 public abstract class CraftEntity implements org.bukkit.entity.Entity {
     private static PermissibleBase perm;
@@ -1070,7 +1076,10 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
                 for (net.minecraft.world.level.chunk.ChunkAccess chunk : list) {
                     chunkProviderServer.addTicketAtLevel(net.minecraft.server.level.TicketType.POST_TELEPORT, chunk.getPos(), 33, CraftEntity.this.getEntityId());
                 }
-                net.minecraft.server.MinecraftServer.getServer().scheduleOnMain(() -> {
+                MultiPaperRegionScheduler.scheduleAcrossLevels(
+                        (ServerLevel) CraftEntity.this.getHandle().level(), RegionPos.forChunk(CraftEntity.this.getHandle().chunkPosition()),
+                        world, RegionPos.forLocation(locationClone),
+                        () -> { // MultiPaper - Run teleports on the correct threads
                     try {
                         ret.complete(CraftEntity.this.teleport(locationClone, cause, teleportFlags) ? Boolean.TRUE : Boolean.FALSE);
                     } catch (Throwable throwable) {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 241340a6d66f17f2a31fb03ff0dfab121b856368..e1c1b5a10efb492b92bf45915048a711fd1c5227 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -3355,7 +3355,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         {
             if ( CraftPlayer.this.getHealth() <= 0 && CraftPlayer.this.isOnline() )
             {
-                CraftPlayer.this.server.getServer().getPlayerList().respawn( CraftPlayer.this.getHandle(), false, org.bukkit.event.player.PlayerRespawnEvent.RespawnReason.PLUGIN );
+                CraftPlayer.this.server.getServer().getPlayerList().respawnAsync( CraftPlayer.this.getHandle(), false, org.bukkit.event.player.PlayerRespawnEvent.RespawnReason.PLUGIN ); // MultiPaper - async respawning
             }
         }
 

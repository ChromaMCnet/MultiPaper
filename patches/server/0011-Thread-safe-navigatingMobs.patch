From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Sun, 5 May 2024 17:02:23 +0900
Subject: [PATCH] Thread-safe navigatingMobs


diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 296768dad4aa4aa7b7bb162088dde63446ccdd92..89d05336421e683c563d43539280a05882364909 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -407,6 +407,7 @@ public class ServerChunkCache extends ChunkSource {
     }
 
     public boolean pollTask() {
+        if (MultiPaperTickThread.isMultiPaperTickThread()) return false; // MultiPaper - don't run main thread tasks on worker threads
         return this.mainThreadProcessor.pollTask();
     }
 
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index c5e2f280d9abeaaa141d68eddd63300f6ede9810..dc5f3bb5cbe01fa0aed38f78683c76c551e49369 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -6,6 +6,7 @@ import com.google.common.collect.Lists;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
+import io.papermc.paper.util.TickThread;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.longs.LongSet;
@@ -204,7 +205,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
     private final LevelTicks<Fluid> fluidTicks;
     private final PathTypeCache pathTypesByPosCache;
     final Set<Mob> navigatingMobs;
-    volatile boolean isUpdatingNavigations;
+    final ThreadLocal<Boolean> isUpdatingNavigations = ThreadLocal.withInitial(() -> false); // MultiPaper - make thread local
     protected final Raids raids;
     private final ObjectLinkedOpenHashSet<BlockEventData> blockEvents;
     private final List<BlockEventData> blockEventsToReschedule;
@@ -1916,7 +1917,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
     @Override
     public void sendBlockUpdated(BlockPos pos, BlockState oldState, BlockState newState, int flags) {
-        if (this.isUpdatingNavigations) {
+        if (this.isUpdatingNavigations.get()) { // MultiPaper - use thread local
             String s = "recursive call to sendBlockUpdated";
 
             Util.logAndPauseIfInIde("recursive call to sendBlockUpdated", new IllegalStateException("recursive call to sendBlockUpdated"));
@@ -1930,7 +1931,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
         if (Shapes.joinIsNotEmpty(voxelshape, voxelshape1, BooleanOp.NOT_SAME)) {
             List<PathNavigation> list = new ObjectArrayList();
-            Iterator iterator = this.navigatingMobs.iterator();
+            Iterator iterator = chunkSource.tickingRegions.collectRelevantNavigatingMobs(RegionPos.forChunk(new ChunkPos(pos))).iterator(); // MultiPaper
 
             while (iterator.hasNext()) {
                 // CraftBukkit start - fix SPIGOT-6362
@@ -1953,7 +1954,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
             }
 
             try {
-                this.isUpdatingNavigations = true;
+                this.isUpdatingNavigations.set(true); // MultiPaper - use thread local
                 iterator = list.iterator();
 
                 while (iterator.hasNext()) {
@@ -1962,7 +1963,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
                     navigationabstract1.recomputePath();
                 }
             } finally {
-                this.isUpdatingNavigations = false;
+                this.isUpdatingNavigations.set(false); // MultiPaper - use thread local
             }
 
         }
@@ -2778,7 +2779,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         }
 
         public void onTrackingStart(Entity entity) {
-            org.spigotmc.AsyncCatcher.catchOp("entity register"); // Spigot
+            TickThread.ensureTickThread(entity, "entity register"); // org.spigotmc.AsyncCatcher.catchOp("entity register"); // Spigot // MultiPaper
             // ServerLevel.this.getChunkSource().addEntity(entity); // Paper - ignore and warn about illegal addEntity calls instead of crashing server; moved down below valid=true
             if (entity instanceof ServerPlayer entityplayer) {
                 ServerLevel.this.players.add(entityplayer);
@@ -2786,13 +2787,13 @@ public class ServerLevel extends Level implements WorldGenLevel {
             }
 
             if (entity instanceof Mob entityinsentient) {
-                if (false && ServerLevel.this.isUpdatingNavigations) { // Paper - Remove unnecessary onTrackingStart during navigation warning
+                if (false && ServerLevel.this.isUpdatingNavigations.get()) { // Paper - Remove unnecessary onTrackingStart during navigation warning // MultiPaper - use thread local
                     String s = "onTrackingStart called during navigation iteration";
 
                     Util.logAndPauseIfInIde("onTrackingStart called during navigation iteration", new IllegalStateException("onTrackingStart called during navigation iteration"));
                 }
 
-                ServerLevel.this.navigatingMobs.add(entityinsentient);
+                chunkSource.tickingRegions.addNavigationMob(entityinsentient); // ServerLevel.this.navigatingMobs.add(entityinsentient); // MultiPaper
             }
 
             if (entity instanceof EnderDragon entityenderdragon) {
@@ -2823,7 +2824,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         }
 
         public void onTrackingEnd(Entity entity) {
-            org.spigotmc.AsyncCatcher.catchOp("entity unregister"); // Spigot
+            TickThread.ensureTickThread(entity, "entity unregister"); // org.spigotmc.AsyncCatcher.catchOp("entity unregister"); // Spigot // MultiPaper
             // Spigot start
             if ( entity instanceof Player )
             {
@@ -2867,13 +2868,13 @@ public class ServerLevel extends Level implements WorldGenLevel {
             }
 
             if (entity instanceof Mob entityinsentient) {
-                if (false && ServerLevel.this.isUpdatingNavigations) { // Paper - Remove unnecessary onTrackingStart during navigation warning
+                if (false && ServerLevel.this.isUpdatingNavigations.get()) { // Paper - Remove unnecessary onTrackingStart during navigation warning // MultiPaper - use thread local
                     String s = "onTrackingStart called during navigation iteration";
 
                     Util.logAndPauseIfInIde("onTrackingStart called during navigation iteration", new IllegalStateException("onTrackingStart called during navigation iteration"));
                 }
 
-                ServerLevel.this.navigatingMobs.remove(entityinsentient);
+                chunkSource.tickingRegions.removeNavigationMob(entityinsentient); // ServerLevel.this.navigatingMobs.remove(entityinsentient); // MultiPaper
             }
 
             if (entity instanceof EnderDragon entityenderdragon) {
diff --git a/src/main/java/puregero/multipaper/region/LevelChunkRegion.java b/src/main/java/puregero/multipaper/region/LevelChunkRegion.java
index 65166e43ae0b69174e12b431fdb4a6925e0976e3..c8c16c829eaa2a67d086d09d82283d70f96d5323 100644
--- a/src/main/java/puregero/multipaper/region/LevelChunkRegion.java
+++ b/src/main/java/puregero/multipaper/region/LevelChunkRegion.java
@@ -1,10 +1,13 @@
 package puregero.multipaper.region;
 
 import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedThreadedTaskQueue;
+import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
 import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.Mob;
 import net.minecraft.world.level.chunk.LevelChunk;
 
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.function.Consumer;
@@ -16,6 +19,7 @@ public class LevelChunkRegion {
     private final List<LevelChunk> levelChunks = new ArrayList<>(RegionPos.REGION_SIZE * RegionPos.REGION_SIZE);
     private final ConcurrentLinkedQueue<DelayedTask> scheduledTasks = new ConcurrentLinkedQueue<>();
     private final PrioritisedThreadedTaskQueue internalTasks = new PrioritisedThreadedTaskQueue();
+    private final ObjectOpenHashSet<Mob> navigatingMobs = new ObjectOpenHashSet<>();
 
     public LevelChunkRegion(ServerLevel level, RegionPos regionPos) {
         this.level = level;
@@ -40,6 +44,18 @@ public class LevelChunkRegion {
         return internalTasks;
     }
 
+    public synchronized void addNavigationMob(Mob mob) {
+        navigatingMobs.add(mob);
+    }
+
+    public synchronized void removeNavigationMob(Mob mob) {
+        navigatingMobs.remove(mob);
+    }
+
+    public synchronized void collectNavigatingMobs(List<Mob> collection) {
+        collection.addAll(this.navigatingMobs);
+    }
+
     public RegionPos getRegionPos() {
         return regionPos;
     }
@@ -74,6 +90,6 @@ public class LevelChunkRegion {
     }
 
     public boolean isEmpty() {
-        return levelChunks.isEmpty() && scheduledTasks.isEmpty() && internalTasks.getTotalTasksExecuted() >= internalTasks.getTotalTasksScheduled();
+        return levelChunks.isEmpty() && scheduledTasks.isEmpty() && internalTasks.getTotalTasksExecuted() >= internalTasks.getTotalTasksScheduled() && navigatingMobs.isEmpty();
     }
 }
diff --git a/src/main/java/puregero/multipaper/region/LevelChunkRegionMap.java b/src/main/java/puregero/multipaper/region/LevelChunkRegionMap.java
index 607004069df259785ac3227ca538b988e21371ce..7799c6982bcc826efb103674cc37e0031ec1d705 100644
--- a/src/main/java/puregero/multipaper/region/LevelChunkRegionMap.java
+++ b/src/main/java/puregero/multipaper/region/LevelChunkRegionMap.java
@@ -1,8 +1,11 @@
 package puregero.multipaper.region;
 
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.Mob;
 import net.minecraft.world.level.chunk.LevelChunk;
+import puregero.multipaper.threading.MultiPaperRegionLocker;
 import puregero.multipaper.util.SimpleStampedLock;
 
 import java.util.ArrayList;
@@ -78,4 +81,36 @@ public class LevelChunkRegionMap {
         getOrCreate(regionPos).getInternalTaskQueue().queueRunnable(task);
     }
 
+    public void addNavigationMob(Mob mob) {
+        getOrCreate(RegionPos.forChunk(mob.chunkPosition())).addNavigationMob(mob);
+    }
+
+    public void removeNavigationMob(Mob mob) {
+        getOrCreate(RegionPos.forChunk(mob.chunkPosition())).removeNavigationMob(mob);
+    }
+
+    public List<Mob> collectRelevantNavigatingMobs(RegionPos regionPos) {
+        if (!level.chunkScheduler.getRegionLocker().hasLock(regionPos)) {
+            // We care about the navigating mobs in at least this region, ensure it's locked
+            throw new IllegalStateException("Collecting navigating mobs outside of region's thread");
+        }
+
+        ObjectArrayList<Mob> navigatingMobs = new ObjectArrayList<>();
+
+        for (int x = -MultiPaperRegionLocker.REGION_LOCK_RADIUS; x <= MultiPaperRegionLocker.REGION_LOCK_RADIUS; x++) {
+            for (int z = -MultiPaperRegionLocker.REGION_LOCK_RADIUS; z <= MultiPaperRegionLocker.REGION_LOCK_RADIUS; z++) {
+                RegionPos i = new RegionPos(regionPos.x + x, regionPos.z + z);
+
+                // Only collect mobs from regions that are locked - if it's not locked, it should be too far away to matter
+                if (!level.chunkScheduler.getRegionLocker().hasLock(i)) continue;
+
+                LevelChunkRegion region = get(i);
+                if (region == null) continue;
+
+                region.collectNavigatingMobs(navigatingMobs);
+            }
+        }
+
+        return navigatingMobs;
+    }
 }
\ No newline at end of file

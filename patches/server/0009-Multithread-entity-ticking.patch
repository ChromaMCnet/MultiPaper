From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Sun, 5 May 2024 13:59:19 +0900
Subject: [PATCH] Multithread entity ticking


diff --git a/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java b/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
index c78cbec447032de9fe69748591bef6be300160ed..c2a179466598961aabcaf7c96ec3f5ea624a441b 100644
--- a/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
+++ b/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
@@ -23,6 +23,7 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
+import java.util.function.Consumer;
 import java.util.function.Predicate;
 import org.bukkit.event.entity.EntityRemoveEvent;
 
@@ -149,6 +150,18 @@ public final class ChunkEntitySlices {
         return collectedEntities;
     }
 
+    // MultiPaper start - add kinda-thread-safe iteration (ie, don't error if entities are removed during iteration)
+    public void forEach(Consumer<Entity> action) {
+        Entity[] entities = this.entities.getRawData();
+        for (int i = 0; i < entities.length; ++i) {
+            Entity entity = entities[i];
+            if (entity != null) {
+                action.accept(entity);
+            }
+        }
+    }
+    // MultiPaper end
+
     public void callEntitiesLoadEvent() {
         CraftEventFactory.callEntitiesLoadEvent(this.world, new ChunkPos(this.chunkX, this.chunkZ), this.getAllEntities());
     }
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 21d27f95247270c3c78d630cd76e02af57f9e84a..ad88bd9d6e77caf322d8f9d7fc52c38bee20bda0 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -916,32 +916,32 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
             org.spigotmc.ActivationRange.activateEntities(this); // Spigot
             //this.timings.entityTick.startTiming(); // Spigot // Purpur
-            this.entityTickList.forEach((entity) -> {
-                if (!entity.isRemoved()) {
-                    if (false && this.shouldDiscardEntity(entity)) { // CraftBukkit - We prevent spawning in general, so this butchering is not needed
-                        entity.discard();
-                    } else if (!tickratemanager.isEntityFrozen(entity)) {
-                        //gameprofilerfiller.push("checkDespawn"); // Purpur
-                        entity.checkDespawn();
-                        //gameprofilerfiller.pop(); // Purpur
-                        if (true || this.chunkSource.chunkMap.getDistanceManager().inEntityTickingRange(entity.chunkPosition().toLong())) { // Paper - now always true if in the ticking list
-                            Entity entity1 = entity.getVehicle();
-
-                            if (entity1 != null) {
-                                if (!entity1.isRemoved() && entity1.hasPassenger(entity)) {
-                                    return;
-                                }
-
-                                entity.stopRiding();
-                            }
-
-                            //gameprofilerfiller.push("tick"); // Purpur
-                            this.guardEntityTick(this::tickNonPassenger, entity);
-                            //gameprofilerfiller.pop(); // Purpur
-                        }
-                    }
-                }
-            });
+//            this.entityTickList.forEach((entity) -> {
+//                if (!entity.isRemoved()) {
+//                    if (false && this.shouldDiscardEntity(entity)) { // CraftBukkit - We prevent spawning in general, so this butchering is not needed
+//                        entity.discard();
+//                    } else if (!tickratemanager.isEntityFrozen(entity)) {
+//                        //gameprofilerfiller.push("checkDespawn"); // Purpur
+//                        entity.checkDespawn();
+//                        //gameprofilerfiller.pop(); // Purpur
+//                        if (true || this.chunkSource.chunkMap.getDistanceManager().inEntityTickingRange(entity.chunkPosition().toLong())) { // Paper - now always true if in the ticking list
+//                            Entity entity1 = entity.getVehicle();
+//
+//                            if (entity1 != null) {
+//                                if (!entity1.isRemoved() && entity1.hasPassenger(entity)) {
+//                                    return;
+//                                }
+//
+//                                entity.stopRiding();
+//                            }
+//
+//                            //gameprofilerfiller.push("tick"); // Purpur
+//                            this.guardEntityTick(this::tickNonPassenger, entity);
+//                            //gameprofilerfiller.pop(); // Purpur
+//                        }
+//                    }
+//                }
+//            });
             //this.timings.entityTick.stopTiming(); // Spigot // Purpur
             //this.timings.tickEntities.stopTiming(); // Spigot // Purpur
             //gameprofilerfiller.pop(); // Purpur
@@ -1009,7 +1009,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
     }
 
-    private boolean shouldDiscardEntity(Entity entity) {
+    public boolean shouldDiscardEntity(Entity entity) { // MultiPaper - make public
         return !this.server.isSpawningAnimals() && (entity instanceof Animal || entity instanceof WaterAnimal) ? true : !this.server.areNpcsEnabled() && entity instanceof Npc;
     }
 
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 8f7a1f1e3be9a7a2dd86d6f1dd836aa5b242a258..e6c3a7367999e9a8d3fe7c53c38953490319aeca 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -1345,7 +1345,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public <T extends Entity> void guardEntityTick(Consumer<T> tickConsumer, T entity) {
         try {
             tickConsumer.accept(entity);
-            MinecraftServer.getServer().executeMidTickTasks(); // Paper - execute chunk tasks mid tick
+            // MinecraftServer.getServer().executeMidTickTasks(); // Paper - execute chunk tasks mid tick // MultiPaper - disable
         } catch (Throwable throwable) {
             if (throwable instanceof ThreadDeath) throw throwable; // Paper
             // Paper start - Prevent block entity and entity crashes
diff --git a/src/main/java/net/minecraft/world/level/entity/EntityTickList.java b/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
index 83a39f900551e39d5af6f17a339a386ddee4feef..f0ab5850feb92c5e6bb4eba6c8a395a6b36f0e95 100644
--- a/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
+++ b/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
@@ -1,5 +1,6 @@
 package net.minecraft.world.level.entity;
 
+import io.papermc.paper.chunk.system.entity.EntityLookup;
 import it.unimi.dsi.fastutil.ints.Int2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMaps;
@@ -16,22 +17,26 @@ public class EntityTickList {
     }
 
     public void add(Entity entity) {
+        if (true) return; // MultiPaper - disable the entity tick list
         io.papermc.paper.util.TickThread.ensureTickThread("Asynchronous entity ticklist addition"); // Paper
         this.ensureActiveIsNotIterated();
         this.entities.add(entity); // Paper - replace with better logic, do not delay removals/additions
     }
 
     public void remove(Entity entity) {
+        if (true) return; // MultiPaper - disable the entity tick list
         io.papermc.paper.util.TickThread.ensureTickThread("Asynchronous entity ticklist removal"); // Paper
         this.ensureActiveIsNotIterated();
         this.entities.remove(entity); // Paper - replace with better logic, do not delay removals/additions
     }
 
     public boolean contains(Entity entity) {
+        if (true) return EntityLookup.getEntityStatus(entity).isTicking(); // MultiPaper - disable the entity tick list
         return this.entities.contains(entity); // Paper - replace with better logic, do not delay removals/additions
     }
 
     public void forEach(Consumer<Entity> action) {
+        if (true) throw new IllegalStateException("EntityTickList has been removed"); // MultiPaper - disable the entity tick list
         io.papermc.paper.util.TickThread.ensureTickThread("Asynchronous entity ticklist iteration"); // Paper
         // Paper start - replace with better logic, do not delay removals/additions
         // To ensure nothing weird happens with dimension travelling, do not iterate over new entries...
diff --git a/src/main/java/puregero/multipaper/threading/MultiPaperChunkTicker.java b/src/main/java/puregero/multipaper/threading/MultiPaperChunkTicker.java
index 9cc226c540cb13fa2ee04ccdb92efadb21edbef7..509219927c274f7170764d7cb0d4c9a9779fc3b5 100644
--- a/src/main/java/puregero/multipaper/threading/MultiPaperChunkTicker.java
+++ b/src/main/java/puregero/multipaper/threading/MultiPaperChunkTicker.java
@@ -4,6 +4,7 @@ import com.mojang.logging.LogUtils;
 import io.papermc.paper.util.player.NearbyPlayers;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ChunkMap;
+import net.minecraft.server.level.FullChunkStatus;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.level.ChunkPos;
@@ -96,6 +97,10 @@ public class MultiPaperChunkTicker {
                 // if ((chunksTicked++ & 1) == 0) net.minecraft.server.MinecraftServer.getServer().executeMidTickTasks(); // Paper // MultiPaper - does this need to be implemented??
             }
         }
+
+        if (chunk1.chunkStatus.isOrAfter(FullChunkStatus.ENTITY_TICKING)) {
+            chunk1.getChunkHolder().getEntityChunk().forEach(MultiPaperEntityTicker::tickEntity);
+        }
     }
 
 }
diff --git a/src/main/java/puregero/multipaper/threading/MultiPaperEntityTicker.java b/src/main/java/puregero/multipaper/threading/MultiPaperEntityTicker.java
new file mode 100644
index 0000000000000000000000000000000000000000..68b41b85db26bb7e7ff3ed03b7a9a652b0d1371e
--- /dev/null
+++ b/src/main/java/puregero/multipaper/threading/MultiPaperEntityTicker.java
@@ -0,0 +1,37 @@
+package puregero.multipaper.threading;
+
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.Entity;
+
+public class MultiPaperEntityTicker {
+
+    public static void tickEntity(Entity entity) {
+        ServerLevel level = (ServerLevel) entity.level();
+
+        if (!entity.isRemoved()) {
+            if (false && level.shouldDiscardEntity(entity)) { // CraftBukkit - We prevent spawning in general, so this butchering is not needed
+                entity.discard();
+            } else if (!level.tickRateManager().isEntityFrozen(entity)) {
+                //gameprofilerfiller.push("checkDespawn"); // Purpur
+                entity.checkDespawn();
+                //gameprofilerfiller.pop(); // Purpur
+                if (true || level.chunkSource.chunkMap.getDistanceManager().inEntityTickingRange(entity.chunkPosition().toLong())) { // Paper - now always true if in the ticking list
+                    Entity entity1 = entity.getVehicle();
+
+                    if (entity1 != null) {
+                        if (!entity1.isRemoved() && entity1.hasPassenger(entity)) {
+                            return;
+                        }
+
+                        entity.stopRiding();
+                    }
+
+                    //gameprofilerfiller.push("tick"); // Purpur
+                    level.guardEntityTick(level::tickNonPassenger, entity);
+                    //gameprofilerfiller.pop(); // Purpur
+                }
+            }
+        }
+    }
+
+}

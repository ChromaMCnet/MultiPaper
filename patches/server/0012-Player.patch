From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Sun, 12 May 2024 23:54:34 +0900
Subject: [PATCH] Player


diff --git a/src/main/java/io/papermc/paper/chunk/system/RegionizedPlayerChunkLoader.java b/src/main/java/io/papermc/paper/chunk/system/RegionizedPlayerChunkLoader.java
index 149cfb0587299f72fcfddf395fb71b70438986c1..d30318db91be7b8bdf86ca0f5c254e9c93b1b623 100644
--- a/src/main/java/io/papermc/paper/chunk/system/RegionizedPlayerChunkLoader.java
+++ b/src/main/java/io/papermc/paper/chunk/system/RegionizedPlayerChunkLoader.java
@@ -32,6 +32,8 @@ import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.levelgen.BelowZeroRetrogen;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.entity.Player;
+import puregero.multipaper.region.RegionPos;
+
 import java.lang.invoke.VarHandle;
 import java.util.ArrayDeque;
 import java.util.Arrays;
@@ -312,6 +314,7 @@ public class RegionizedPlayerChunkLoader {
 
     public void tick() {
         TickThread.ensureTickThread("Cannot tick player chunk loader async");
+        if (true) return; // MultiPaper - why is this not just run under the player ticking system?
         long currTime = System.nanoTime();
         for (final ServerPlayer player : new java.util.ArrayList<>(this.world.players())) {
             final PlayerChunkLoaderData loader = player.chunkLoader;
@@ -609,7 +612,7 @@ public class RegionizedPlayerChunkLoader {
             return Math.max(Math.abs(dx), Math.abs(dz)) <= this.lastTickDistance;
         }
 
-        void updateQueues(final long time) {
+        public void updateQueues(final long time) { // MultiPaper - make public
             TickThread.ensureTickThread(this.player, "Cannot tick player chunk loader async");
             if (this.removed) {
                 throw new IllegalStateException("Ticking removed player chunk loader");
@@ -801,11 +804,12 @@ public class RegionizedPlayerChunkLoader {
                 final int pendingSendX = CoordinateUtils.getChunkX(pendingSend);
                 final int pendingSendZ = CoordinateUtils.getChunkZ(pendingSend);
                 final LevelChunk chunk = this.world.chunkSource.getChunkAtIfLoadedMainThreadNoCache(pendingSendX, pendingSendZ);
-                if (!chunk.areNeighboursLoaded(1) || !TickThread.isTickThreadFor(this.world, pendingSendX, pendingSendZ)) {
+                if (!chunk.areNeighboursLoaded(1)) { // MultiPaper - do thread check later
                     // nothing to do
                     // the target chunk may not be owned by this region, but this should be resolved in the future
                     break;
                 }
+                Runnable runOnThread = () -> { // MultiPaper - run on region's thread
                 if (!chunk.isPostProcessingDone) {
                     // not yet post-processed, need to do this so that tile entities can properly be sent to clients
                     chunk.postProcessGeneration();
@@ -817,6 +821,14 @@ public class RegionizedPlayerChunkLoader {
                 this.sendQueue.dequeueLong();
 
                 this.sendChunk(pendingSendX, pendingSendZ);
+                // MultiPaper start - run on region's thread
+                };
+                if (TickThread.isTickThreadFor(this.world, chunk.getPos())) {
+                    runOnThread.run();
+                } else {
+                    this.world.chunkScheduler.getRegionLocker().tryReadOnlyLockNow(RegionPos.forChunk(chunk.getPos()), runOnThread);
+                }
+                // MultiPaper end - run on region's thread
                 if (this.removed) {
                     // sendChunk may invoke plugin logic
                     return;
@@ -873,7 +885,7 @@ public class RegionizedPlayerChunkLoader {
             );
         }
 
-        void update() {
+        public void update() { // MultiPaper - make public
             TickThread.ensureTickThread(this.player, "Cannot update player asynchronously");
             if (this.removed) {
                 throw new IllegalStateException("Updating removed player chunk loader");
diff --git a/src/main/java/net/minecraft/network/Connection.java b/src/main/java/net/minecraft/network/Connection.java
index 71b021513f30376c7b09d83059deea89cc92385f..9d238746800fb7c2031be8be0dad803c981804ec 100644
--- a/src/main/java/net/minecraft/network/Connection.java
+++ b/src/main/java/net/minecraft/network/Connection.java
@@ -42,6 +42,8 @@ import java.util.function.Consumer;
 import java.util.function.Supplier;
 import javax.annotation.Nullable;
 import javax.crypto.Cipher;
+
+import io.papermc.paper.util.TickThread;
 import net.minecraft.SharedConstants;
 import net.minecraft.Util;
 import net.minecraft.network.chat.Component;
@@ -60,12 +62,14 @@ import net.minecraft.network.protocol.login.LoginProtocols;
 import net.minecraft.network.protocol.status.ClientStatusPacketListener;
 import net.minecraft.network.protocol.status.StatusProtocols;
 import net.minecraft.server.RunningOnDifferentThreadException;
+import net.minecraft.server.network.ServerGamePacketListenerImpl;
 import net.minecraft.util.Mth;
 import net.minecraft.util.debugchart.LocalSampleLogger;
 import org.apache.commons.lang3.Validate;
 import org.slf4j.Logger;
 import org.slf4j.Marker;
 import org.slf4j.MarkerFactory;
+import puregero.multipaper.MultiPaper;
 
 public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
 
@@ -610,6 +614,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     private static int currTick; // Paper - Buffer joins to world
     private static int tickSecond; // Purpur
     public void tick() {
+        if (this.packetListener instanceof ServerGamePacketListenerImpl serverGamePacketListener && !TickThread.isTickThreadFor(serverGamePacketListener.player)) return; // MultiPaper
         this.flushQueue();
         // Paper start - Buffer joins to world
         if (Connection.currTick != net.minecraft.server.MinecraftServer.currentTick) {
diff --git a/src/main/java/net/minecraft/network/protocol/PacketUtils.java b/src/main/java/net/minecraft/network/protocol/PacketUtils.java
index 8c134a642ccaf3530022f2e675a858d726e1dda4..e1fc0303aba37cf1166bf1a14d4613ee91f9a1e5 100644
--- a/src/main/java/net/minecraft/network/protocol/PacketUtils.java
+++ b/src/main/java/net/minecraft/network/protocol/PacketUtils.java
@@ -1,10 +1,12 @@
 package net.minecraft.network.protocol;
 
 import com.mojang.logging.LogUtils;
+import io.papermc.paper.util.TickThread;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportedException;
 import net.minecraft.network.PacketListener;
+import net.minecraft.server.network.ServerGamePacketListenerImpl;
 import org.slf4j.Logger;
 
 // CraftBukkit start
@@ -14,6 +16,7 @@ import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.network.ServerCommonPacketListenerImpl;
 // CraftBukkit end
 import net.minecraft.util.thread.BlockableEventLoop;
+import puregero.multipaper.MultiPaper;
 
 public class PacketUtils {
 
@@ -44,6 +47,33 @@ public class PacketUtils {
     }
 
     public static <T extends PacketListener> void ensureRunningOnSameThread(Packet<T> packet, T listener, BlockableEventLoop<?> engine) throws RunningOnDifferentThreadException {
+        // MultiPaper start - run on player's thread
+        if (listener instanceof ServerGamePacketListenerImpl gamePacketListener) {
+            if (TickThread.isTickThreadFor(gamePacketListener.player)) return;
+            MultiPaper.runSync(gamePacketListener.player, () -> {
+                if (listener instanceof ServerCommonPacketListenerImpl serverCommonPacketListener && serverCommonPacketListener.processedDisconnect) return; // CraftBukkit - Don't handle sync packets for kicked players
+                if (listener.shouldHandleMessage(packet)) {
+                    co.aikar.timings.Timing timing = co.aikar.timings.MinecraftTimings.getPacketTiming(packet); // Paper - timings
+                    try { // Paper - timings // Purpur
+                        packet.handle(listener);
+                    } catch (Exception exception) {
+                        if (exception instanceof ReportedException) {
+                            ReportedException reportedexception = (ReportedException) exception;
+
+                            if (reportedexception.getCause() instanceof OutOfMemoryError) {
+                                throw PacketUtils.makeReportedException(exception, packet, listener);
+                            }
+                        }
+
+                        listener.onPacketError(packet, exception);
+                    }
+                } else {
+                    PacketUtils.LOGGER.debug("Ignoring packet due to disconnection: {}", packet);
+                }
+            });
+            throw RunningOnDifferentThreadException.RUNNING_ON_DIFFERENT_THREAD;
+        }
+        // MultiPaper end - run on player's thread
         if (!engine.isSameThread()) {
             engine.executeIfPossible(() -> {
                 packetProcessing.push(listener); // Paper - detailed watchdog information
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index b52b1ffe427ae4ae6c51d8eb2f1e78349edb2a05..0014e9a9f09515e64c6ead9445ca5268d89b08a7 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1787,6 +1787,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
         // Paper end - Perf: Optimize time updates
         //MinecraftTimings.timeUpdateTimer.stopTiming(); // Spigot // Paper // Purpur
+        this.getConnection().tick(); // MultiPaper - moved up
 
         this.isIteratingOverLevels = true; // Paper - Throw exception on world create while being ticked
         Iterator iterator = this.getAllLevels().iterator(); // Paper - Throw exception on world create while being ticked; move down
@@ -1837,7 +1838,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
         //this.profiler.popPush("connection"); // Purpur
         // MinecraftTimings.connectionTimer.startTiming(); // Spigot // Paper // Purpur
-        this.getConnection().tick();
+        // this.getConnection().tick(); // MultiPaper - move up
         // MinecraftTimings.connectionTimer.stopTiming(); // Spigot // Paper // Purpur
         //this.profiler.popPush("players"); // Purpur
         //MinecraftTimings.playerListTimer.startTiming(); // Spigot // Paper // Purpur
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index dc5f3bb5cbe01fa0aed38f78683c76c551e49369..5c9f33457252f17bcc2a97242a726934040ebc94 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -31,6 +31,7 @@ import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
 import java.util.function.Function;
@@ -703,7 +704,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         this.convertable = convertable_conversionsession;
         this.uuid = WorldUUID.getUUID(convertable_conversionsession.levelDirectory.path().toFile());
         // CraftBukkit end
-        this.players = Lists.newArrayList();
+        this.players = new CopyOnWriteArrayList<>(); // MultiPaper - thread-safe (players should not be changing worlds often, thus copy-on-write is sufficient)
         this.entityTickList = new EntityTickList();
         this.blockTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded, this.getProfilerSupplier());
         this.fluidTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded, this.getProfilerSupplier());
@@ -2783,6 +2784,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
             // ServerLevel.this.getChunkSource().addEntity(entity); // Paper - ignore and warn about illegal addEntity calls instead of crashing server; moved down below valid=true
             if (entity instanceof ServerPlayer entityplayer) {
                 ServerLevel.this.players.add(entityplayer);
+                ServerLevel.this.getChunkSource().tickingRegions.addPlayer(entityplayer); // MultiPaper - add player to region
                 ServerLevel.this.updateSleepingPlayerList();
             }
 
@@ -2864,6 +2866,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
             ServerLevel.this.getChunkSource().removeEntity(entity);
             if (entity instanceof ServerPlayer entityplayer) {
                 ServerLevel.this.players.remove(entityplayer);
+                ServerLevel.this.getChunkSource().tickingRegions.removePlayer(entityplayer); // MultiPaper - remove player from region
                 ServerLevel.this.updateSleepingPlayerList();
             }
 
@@ -2902,6 +2905,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
         public void onSectionChange(Entity entity) {
             entity.updateDynamicGameEventListener(DynamicGameEventListener::move);
+            if (entity instanceof ServerPlayer serverPlayer) ServerLevel.this.chunkSource.tickingRegions.movePlayer(serverPlayer); // MultiPpaer - move player into the new region
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index a7ba658a4dc6eeb9d5bc854289c21b3bd21646b1..162087bd74f53dce7eef9efa7e85c83538db23a7 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -16,8 +16,11 @@ import java.util.Optional;
 import java.util.OptionalInt;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
 import java.util.stream.Collectors;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.util.TickThread;
 import net.minecraft.BlockUtil;
 import net.minecraft.ChatFormatting;
 import net.minecraft.CrashReport;
@@ -194,6 +197,7 @@ import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
 import org.bukkit.event.player.PlayerToggleSneakEvent;
 import org.bukkit.inventory.MainHand;
+import puregero.multipaper.MultiPaper;
 // CraftBukkit end
 
 public class ServerPlayer extends Player {
@@ -245,6 +249,7 @@ public class ServerPlayer extends Player {
     private Vec3 enteredLavaOnVehiclePosition;
     private SectionPos lastSectionPos;
     private ChunkTrackingView chunkTrackingView;
+    public ChunkPos previousChunkPosRegion; // MultiPaper
     private ResourceKey<Level> respawnDimension;
     @Nullable
     private BlockPos respawnPosition;
@@ -500,7 +505,7 @@ public class ServerPlayer extends Player {
     }
     // CraftBukkit end
 
-    public void fudgeSpawnLocation(ServerLevel world) {
+    public void fudgeSpawnLocation(ServerLevel world, Runnable onComplete) { // MultiPaper - run on region's thread
         BlockPos blockposition = world.getSharedSpawnPos();
 
         if (world.dimensionType().hasSkyLight() && world.serverLevelData.getGameType() != GameType.ADVENTURE) { // CraftBukkit
@@ -521,28 +526,41 @@ public class ServerPlayer extends Player {
             int j1 = this.getCoprime(i1);
             int k1 = RandomSource.create().nextInt(i1);
 
-            for (int l1 = 0; l1 < i1; ++l1) {
-                int i2 = (k1 + j1 * l1) % i1;
-                int j2 = i2 % (i * 2 + 1);
-                int k2 = i2 / (i * 2 + 1);
-                BlockPos blockposition1 = PlayerRespawnLogic.getOverworldRespawnPos(world, blockposition.getX() + j2 - i, blockposition.getZ() + k2 - i);
+            this.findSpawnLocation(world, blockposition, i, i1, j1, k1, 0, onComplete); // MultiPaper - run on region's thread
+        } else {
+            // MultiPaper start - run on region's thread
+            MultiPaper.ensureSync(world, blockposition, () -> {
+                this.moveTo(blockposition, world.getSharedSpawnAngle(), 0.0F); // Paper - MC-200092 - fix first spawn pos yaw being ignored
 
-                if (blockposition1 != null) {
-                    this.moveTo(blockposition1, world.getSharedSpawnAngle(), 0.0F); // Paper - MC-200092 - fix first spawn pos yaw being ignored
-                    if (world.noCollision(this, this.getBoundingBox(), true)) { // Paper - make sure this loads chunks, we default to NOT loading now
-                        break;
-                    }
+                while (!world.noCollision(this, this.getBoundingBox(), true) && this.getY() < (double) (world.getMaxBuildHeight() - 1)) { // Paper - make sure this loads chunks, we default to NOT loading now
+                    this.setPos(this.getX(), this.getY() + 1.0D, this.getZ());
                 }
-            }
-        } else {
-            this.moveTo(blockposition, world.getSharedSpawnAngle(), 0.0F); // Paper - MC-200092 - fix first spawn pos yaw being ignored
+            });
+            // MultiPaper end - run on region's thread
+        }
+
+    }
+
+    // MultiPaper start - run on region's thread
+    private void findSpawnLocation(ServerLevel world, BlockPos blockposition, int i, int i1, int j1, int k1, int l1, Runnable onComplete) {
+        int i2 = (k1 + j1 * l1) % i1;
+        int j2 = i2 % (i * 2 + 1);
+        int k2 = i2 / (i * 2 + 1);
+        MultiPaper.ensureSync(world, new BlockPos(blockposition.getX() + j2 - i, 0, blockposition.getZ() + k2 - i), () -> {
+            BlockPos blockposition1 = PlayerRespawnLogic.getOverworldRespawnPos(world, blockposition.getX() + j2 - i, blockposition.getZ() + k2 - i);
 
-            while (!world.noCollision(this, this.getBoundingBox(), true) && this.getY() < (double) (world.getMaxBuildHeight() - 1)) { // Paper - make sure this loads chunks, we default to NOT loading now
-                this.setPos(this.getX(), this.getY() + 1.0D, this.getZ());
+            if (blockposition1 != null) {
+                this.moveTo(blockposition1, world.getSharedSpawnAngle(), 0.0F); // Paper - MC-200092 - fix first spawn pos yaw being ignored
+                if (world.noCollision(this, this.getBoundingBox(), true)) { // Paper - make sure this loads chunks, we default to NOT loading now
+                    onComplete.run();
+                    return;
+                }
             }
-        }
 
+            this.findSpawnLocation(world, blockposition, i, i1, j1, k1, l1 + 1, onComplete);
+        });
     }
+    // MultiPaper end
 
     private int getCoprime(int horizontalSpawnArea) {
         return horizontalSpawnArea <= 16 ? horizontalSpawnArea - 1 : 17;
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 0c3768bb183451e9dfe94bbc9b203bd79e474b99..94a7194de023208917e29e22b7d5fd9e8d90846c 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -2147,9 +2147,11 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
             this.processedDisconnect = true;
         }
         // CraftBukkit end
+        player.getBukkitEntity().taskScheduler.schedule(e -> { // MultiPaper - run on player's thread
         ServerGamePacketListenerImpl.LOGGER.info("{} lost connection: {}", this.player.getName().getString(), reason.getString());
         this.removePlayerFromWorld(quitMessage); // Paper - Fix kick event leave message not being sent
         super.onDisconnect(reason, quitMessage); // Paper - Fix kick event leave message not being sent
+        }, e -> LOGGER.error("Failed to run disconnect task for player {}", player.getName().getString(), new Exception("Disconnect task retired")), 1); // MultiPaper - run on player's thread
     }
 
     // Paper start - Fix kick event leave message not being sent
@@ -2247,6 +2249,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
     @Override
     public void handleChatCommand(ServerboundChatCommandPacket packet) {
+        PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel()); // MultiPaper - run commands in sync
         this.tryHandleChat(packet.command(), () -> {
             // CraftBukkit start - SPIGOT-7346: Prevent disconnected players from executing commands
             if (this.player.hasDisconnected()) {
@@ -2255,7 +2258,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
             // CraftBukkit end
             this.performUnsignedChatCommand(packet.command());
             this.detectRateSpam("/" + packet.command()); // Spigot
-        }, true); // CraftBukkit - sync commands
+        }, false); // CraftBukkit - sync commands // MultiPaper - we ensure the command is run in sync by ourselves
     }
 
     private void performUnsignedChatCommand(String command) {
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index b863f6fe65c796a1d3102cc3eddb5d6c5becd3ac..e8d6a2b1a0870da97e3a004486ad94a725d313a5 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -122,6 +122,7 @@ import org.bukkit.event.player.PlayerQuitEvent;
 import org.bukkit.event.player.PlayerRespawnEvent;
 import org.bukkit.event.player.PlayerRespawnEvent.RespawnReason;
 import org.bukkit.event.player.PlayerSpawnChangeEvent;
+import puregero.multipaper.MultiPaper;
 // CraftBukkit end
 
 public abstract class PlayerList {
@@ -258,10 +259,20 @@ public abstract class PlayerList {
             player.spawnReason = org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.DEFAULT; // set Player SpawnReason to DEFAULT on first login
             // Paper start - reset to main world spawn if first spawn or invalid world
         }
+        // MultiPaper start - join the region's thread
+        String finalS = s;
+        Runnable onComplete = () -> placeNewPlayer2(connection, player, clientData, worldserver1, optional, finalS);
         if (optional.isEmpty() || invalidPlayerWorld[0]) {
             // Paper end - reset to main world spawn if first spawn or invalid world
-            player.fudgeSpawnLocation(worldserver1); // Paper - Don't move existing players to world spawn
+            player.fudgeSpawnLocation(worldserver1, onComplete); // Paper - Don't move existing players to world spawn // MultiPaper - join the region's thread
+        } else {
+            MultiPaper.ensureSync(worldserver1, player.blockPosition(), onComplete);
         }
+    }
+
+    public void placeNewPlayer2(Connection connection, ServerPlayer player, CommonListenerCookie clientData, ServerLevel worldserver1, Optional<CompoundTag> optional, String s) {
+        // MultiPaper end - join the region's thread
+
         // Paper end - Entity#getEntitySpawnReason
         player.setServerLevel(worldserver1);
         String s1 = connection.getLoggableAddress(this.server.logIPs());
@@ -272,6 +283,13 @@ public abstract class PlayerList {
         this.cserver.getPluginManager().callEvent(ev);
 
         Location loc = ev.getSpawnLocation();
+        // MultiPaper start - join the region's thread
+        MultiPaper.ensureSync(loc, () -> placeNewPlayer3(connection, player, clientData, worldserver1, loc, optional, s, s1));
+    }
+
+    public void placeNewPlayer3(Connection connection, ServerPlayer player, CommonListenerCookie clientData, ServerLevel worldserver1, Location loc, Optional<CompoundTag> optional, String s, String s1) {
+        // MultiPaper end - join the region's thread
+
         worldserver1 = ((CraftWorld) loc.getWorld()).getHandle();
 
         player.spawnIn(worldserver1);
diff --git a/src/main/java/puregero/multipaper/MultiPaper.java b/src/main/java/puregero/multipaper/MultiPaper.java
index 1ffc040d99aa77965b9db019409864d7416013f7..e413ea3b846d6b44e4ba7cbd7bba61f731b6d0d7 100644
--- a/src/main/java/puregero/multipaper/MultiPaper.java
+++ b/src/main/java/puregero/multipaper/MultiPaper.java
@@ -3,6 +3,7 @@ package puregero.multipaper;
 import io.papermc.paper.util.TickThread;
 import net.minecraft.core.BlockPos;
 import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.Entity;
 import net.minecraft.world.level.ChunkPos;
 import org.bukkit.Location;
 import org.bukkit.craftbukkit.CraftWorld;
@@ -14,6 +15,10 @@ public class MultiPaper {
         runSync(((CraftWorld) location.getWorld()).getHandle(), new BlockPos(location.getBlockX(), location.getBlockY(), location.getBlockZ()), runnable);
     }
 
+    public static void runSync(Entity entity, Runnable runnable) {
+        runSync((ServerLevel) entity.level(), entity.chunkPosition(), runnable);
+    }
+
     public static void runSync(ServerLevel serverLevel, BlockPos blockPos, Runnable runnable) {
         runSync(serverLevel, new ChunkPos(blockPos), runnable);
     }
diff --git a/src/main/java/puregero/multipaper/region/LevelChunkRegion.java b/src/main/java/puregero/multipaper/region/LevelChunkRegion.java
index c8c16c829eaa2a67d086d09d82283d70f96d5323..e16024658f7ad8381b6c466f5fc55441b792ea60 100644
--- a/src/main/java/puregero/multipaper/region/LevelChunkRegion.java
+++ b/src/main/java/puregero/multipaper/region/LevelChunkRegion.java
@@ -1,8 +1,10 @@
 package puregero.multipaper.region;
 
 import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedThreadedTaskQueue;
+import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
 import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.entity.Mob;
 import net.minecraft.world.level.chunk.LevelChunk;
 
@@ -20,6 +22,7 @@ public class LevelChunkRegion {
     private final ConcurrentLinkedQueue<DelayedTask> scheduledTasks = new ConcurrentLinkedQueue<>();
     private final PrioritisedThreadedTaskQueue internalTasks = new PrioritisedThreadedTaskQueue();
     private final ObjectOpenHashSet<Mob> navigatingMobs = new ObjectOpenHashSet<>();
+    private final ObjectOpenHashSet<ServerPlayer> players = new ObjectOpenHashSet<>();
 
     public LevelChunkRegion(ServerLevel level, RegionPos regionPos) {
         this.level = level;
@@ -56,6 +59,22 @@ public class LevelChunkRegion {
         collection.addAll(this.navigatingMobs);
     }
 
+    public synchronized void addPlayer(ServerPlayer player) {
+        if (!players.add(player)) {
+            throw new IllegalStateException("Tried to add a player that was already in the region: " + player.getUUID());
+        }
+    }
+
+    public synchronized void removePlayer(ServerPlayer player) {
+        if (!players.remove(player)) {
+            throw new IllegalStateException("Tried to remove a player that wasn't in the region: " + player.getUUID());
+        }
+    }
+
+    public synchronized List<ServerPlayer> getPlayers() {
+        return players.isEmpty() ? List.of() : new ObjectArrayList<>(players);
+    }
+
     public RegionPos getRegionPos() {
         return regionPos;
     }
@@ -90,6 +109,7 @@ public class LevelChunkRegion {
     }
 
     public boolean isEmpty() {
-        return levelChunks.isEmpty() && scheduledTasks.isEmpty() && internalTasks.getTotalTasksExecuted() >= internalTasks.getTotalTasksScheduled() && navigatingMobs.isEmpty();
+        return levelChunks.isEmpty() && scheduledTasks.isEmpty() && internalTasks.getTotalTasksExecuted() >= internalTasks.getTotalTasksScheduled() && navigatingMobs.isEmpty()
+                && players.isEmpty();
     }
 }
diff --git a/src/main/java/puregero/multipaper/region/LevelChunkRegionMap.java b/src/main/java/puregero/multipaper/region/LevelChunkRegionMap.java
index 7799c6982bcc826efb103674cc37e0031ec1d705..2db67f8a6d36bc020a86a4e87b19cf63f8b3e452 100644
--- a/src/main/java/puregero/multipaper/region/LevelChunkRegionMap.java
+++ b/src/main/java/puregero/multipaper/region/LevelChunkRegionMap.java
@@ -3,7 +3,9 @@ package puregero.multipaper.region;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.entity.Mob;
+import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.chunk.LevelChunk;
 import puregero.multipaper.threading.MultiPaperRegionLocker;
 import puregero.multipaper.util.SimpleStampedLock;
@@ -113,4 +115,24 @@ public class LevelChunkRegionMap {
 
         return navigatingMobs;
     }
+
+    public void addPlayer(ServerPlayer player) {
+        player.previousChunkPosRegion = player.chunkPosition();
+        getOrCreate(RegionPos.forChunk(player.chunkPosition())).addPlayer(player);
+    }
+
+    public void removePlayer(ServerPlayer player) {
+        getOrCreate(RegionPos.forChunk(player.chunkPosition())).removePlayer(player);
+    }
+
+    public void movePlayer(ServerPlayer player) {
+        RegionPos fromRegion = RegionPos.forChunk(player.previousChunkPosRegion);
+        RegionPos toRegion = RegionPos.forChunk(player.chunkPosition());
+
+        if (!fromRegion.equals(toRegion)) {
+            player.previousChunkPosRegion = player.chunkPosition();
+            getOrCreate(fromRegion).removePlayer(player);
+            getOrCreate(toRegion).addPlayer(player);
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/puregero/multipaper/threading/MultiPaperChunkTicker.java b/src/main/java/puregero/multipaper/threading/MultiPaperChunkTicker.java
index 88ab6031b615199f43b63c5e2dcd7c566f5c4c50..f708cee785c1e86406d1eab2a29a53f507e79be8 100644
--- a/src/main/java/puregero/multipaper/threading/MultiPaperChunkTicker.java
+++ b/src/main/java/puregero/multipaper/threading/MultiPaperChunkTicker.java
@@ -56,6 +56,8 @@ public class MultiPaperChunkTicker {
         region.tickTasks();
         region.forEach(chunk -> _tickChunk(level, chunk, spawnercreature_d));
 
+        region.getPlayers().forEach(MultiPaperPlayerTicker::tickPlayer);
+
         while (region.getInternalTaskQueue().executeTask());
 
         if (region.isEmpty()) {
diff --git a/src/main/java/puregero/multipaper/threading/MultiPaperPlayerTicker.java b/src/main/java/puregero/multipaper/threading/MultiPaperPlayerTicker.java
new file mode 100644
index 0000000000000000000000000000000000000000..42799f17c69e304dcd4d6170f504f5a0b5629ba0
--- /dev/null
+++ b/src/main/java/puregero/multipaper/threading/MultiPaperPlayerTicker.java
@@ -0,0 +1,19 @@
+package puregero.multipaper.threading;
+
+import io.papermc.paper.chunk.system.RegionizedPlayerChunkLoader;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Entity;
+
+public class MultiPaperPlayerTicker {
+
+    public static void tickPlayer(ServerPlayer serverPlayer) {
+        serverPlayer.connection.connection.tick();
+        final RegionizedPlayerChunkLoader.PlayerChunkLoaderData loader = serverPlayer.chunkLoader;
+        if (loader != null) {
+            loader.update(); // can't invoke plugin logic
+            loader.updateQueues(System.nanoTime());
+        }
+    }
+
+}

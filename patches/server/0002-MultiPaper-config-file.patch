From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Fri, 4 Mar 2022 20:33:33 +1000
Subject: [PATCH] MultiPaper config file


diff --git a/src/main/java/io/multipaper/config/ExceptionableConsumer.java b/src/main/java/io/multipaper/config/ExceptionableConsumer.java
new file mode 100644
index 0000000000000000000000000000000000000000..42bcecd9a556467374c1351b011fc03af97d0cfe
--- /dev/null
+++ b/src/main/java/io/multipaper/config/ExceptionableConsumer.java
@@ -0,0 +1,8 @@
+package io.multipaper.config;
+
+@FunctionalInterface
+public interface ExceptionableConsumer<T> {
+
+    void accept(T t) throws Exception;
+
+}
diff --git a/src/main/java/io/multipaper/config/MultiPaperConfiguration.java b/src/main/java/io/multipaper/config/MultiPaperConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..bb08233c7a09ae472a4994fcf0c3046c8b4e8b01
--- /dev/null
+++ b/src/main/java/io/multipaper/config/MultiPaperConfiguration.java
@@ -0,0 +1,89 @@
+package io.multipaper.config;
+
+import io.papermc.paper.configuration.ConfigurationPart;
+
+import java.util.List;
+
+@SuppressWarnings({ "InnerClassMayBeStatic" })
+public class MultiPaperConfiguration extends ConfigurationPart {
+
+    public static final String HEADER = """
+            This is the main configuration file for MultiPaper.
+            There's quite alot to configure. Read the docs for more information.
+
+            Docs: https://github.com/PureGero/MultiPaper/blob/main/MULTIPAPER_YAML.md\s
+            """;
+
+    private static MultiPaperConfiguration instance;
+
+    public static MultiPaperConfiguration get() {
+        return instance;
+    }
+
+    static void set(MultiPaperConfiguration instance) {
+        MultiPaperConfiguration.instance = instance;
+    }
+
+    public MasterConnection masterConnection;
+
+    public class MasterConnection extends ConfigurationPart  {
+        public boolean advertiseToBuiltInProxy = true;
+
+        // One day we'll get comments in yaml files
+        // @Comment("""
+        //
+        // Set the address used to connect to the master database here.
+        // """)
+        public String masterAddress = "localhost:35353";
+
+        // One day we'll get comments in yaml files
+        // @Comment("""
+        //
+        // Give this server a name. This can be the same name you used for this server in
+        // BungeeCord or Velocity, or you can come up with a random name. Each server must
+        // have a unique name.
+        // """)
+        public String myName = "server" + Double.toString(Math.random()).substring(2, 7);
+    }
+
+    public PeerConnection peerConnection;
+
+    public class PeerConnection extends ConfigurationPart {
+        public int compressionThreshold = 0;
+        public int consolidationDelay = 0;
+    }
+
+    public Optimizations optimizations;
+
+    public class Optimizations extends ConfigurationPart  {
+        public boolean dontSaveJustForLightingUpdates = false;
+        public int maxFootstepPacketsSentPerPlayer = -1;
+        public boolean reducePlayerPositionUpdatesInUnloadedChunks = false;
+        public int ticksPerInactiveEntityTracking = 1;
+        public boolean useEventBasedIo = true;
+    }
+
+    public SyncSettings syncSettings;
+
+    public class SyncSettings extends ConfigurationPart  {
+        public boolean syncEntityIds = true;
+        public boolean syncJsonFiles = true;
+        public boolean syncPermissions = false;
+        public boolean syncScoreboards = true;
+        public boolean useLocalPlayerCountForServerIsFullKick = false;
+        public boolean persistentPlayerEntityIds = true;
+        public int persistentVehicleEntityIdsSeconds = 15;
+
+        public Files files;
+
+        public class Files extends ConfigurationPart {
+            public List<String> filesToNotSync = List.of("plugins/bStats");
+            public List<String> filesToOnlyUploadOnServerStop = List.of("plugins/MyPluginDirectory/my_big_database.db");
+            public List<String> filesToSyncInRealTime = List.of("plugins/MyPluginDirectory/userdata");
+            public List<String> filesToSyncOnStartup = List.of("myconfigfile.yml", "plugins/MyPlugin.jar");
+            public boolean logFileSyncs = true;
+        }
+    }
+
+
+}
diff --git a/src/main/java/io/multipaper/config/MultiPaperConfigurationLoader.java b/src/main/java/io/multipaper/config/MultiPaperConfigurationLoader.java
new file mode 100644
index 0000000000000000000000000000000000000000..165e98977f5382a1983c144de0c17c85e9324149
--- /dev/null
+++ b/src/main/java/io/multipaper/config/MultiPaperConfigurationLoader.java
@@ -0,0 +1,152 @@
+package io.multipaper.config;
+
+import io.papermc.paper.configuration.ConfigurationLoaders;
+import io.papermc.paper.configuration.ConfigurationPart;
+import io.papermc.paper.configuration.constraint.Constraint;
+import io.papermc.paper.configuration.constraint.Constraints;
+import io.papermc.paper.configuration.mapping.InnerClassFieldDiscoverer;
+import org.spongepowered.configurate.BasicConfigurationNode;
+import org.spongepowered.configurate.CommentedConfigurationNode;
+import org.spongepowered.configurate.ConfigurateException;
+import org.spongepowered.configurate.ConfigurationNode;
+import org.spongepowered.configurate.ConfigurationOptions;
+import org.spongepowered.configurate.objectmapping.ObjectMapper;
+import org.spongepowered.configurate.serialize.SerializationException;
+import org.spongepowered.configurate.yaml.YamlConfigurationLoader;
+
+import java.io.File;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.Map;
+import java.util.function.UnaryOperator;
+
+import static io.leangen.geantyref.GenericTypeReflector.erase;
+
+public class MultiPaperConfigurationLoader {
+
+    public static void init(File file) {
+        try {
+            YamlConfigurationLoader.Builder loaderBuilder = ConfigurationLoaders.naturallySorted();
+            loaderBuilder.defaultOptions(options -> options.header(MultiPaperConfiguration.HEADER));
+
+            Path configFile = file.toPath();
+            YamlConfigurationLoader loader = loaderBuilder
+                    .defaultOptions(applyObjectMapperFactory(createObjectMapper().build()))
+                    .path(configFile)
+                    .build();
+            ConfigurationNode node;
+            if (Files.exists(configFile)) {
+                node = loader.load();
+            } else {
+                node = CommentedConfigurationNode.root(loader.defaultOptions());
+            }
+
+            String before = node.toString();
+            setFromProperties(node);
+
+            MultiPaperConfiguration instance = node.require(MultiPaperConfiguration.class);
+            transformLegacyConfig(node, instance);
+
+            for (Object key : node.childrenMap().keySet()) {
+                node.removeChild(key);
+            }
+
+            node.set(instance);
+
+            if (!node.toString().equals(before)) {
+                loader.save(node);
+            }
+
+            MultiPaperConfiguration.set(instance);
+        } catch (ConfigurateException e) {
+            throw new RuntimeException("Could not load multipaper.yml", e);
+        }
+    }
+
+    private static void setFromProperties(ConfigurationNode node) {
+        for (Map.Entry<Object, Object> property : System.getProperties().entrySet()) {
+            if (property.getKey().toString().startsWith("multipaper.")) {
+                String key = property.getKey().toString().substring("multipaper.".length());
+                try {
+                    String value = ((String) property.getValue());
+                    if(value.contains(";")) {
+                        node.node((Object[]) key.split("\\.")).set(value.split(";"));
+                    } else {
+                        node.node((Object[]) key.split("\\.")).set(value);
+                    }
+                } catch (SerializationException e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+    }
+
+    private static ObjectMapper.Factory.Builder createObjectMapper() {
+        return ObjectMapper.factoryBuilder()
+                .addConstraint(Constraint.class, new Constraint.Factory())
+                .addConstraint(Constraints.Min.class, Number.class, new Constraints.Min.Factory())
+                .addDiscoverer(InnerClassFieldDiscoverer.globalConfig());
+    }
+
+    private static UnaryOperator<ConfigurationOptions> applyObjectMapperFactory(final ObjectMapper.Factory factory) {
+        return options -> options.serializers(builder -> builder
+                .register(type -> ConfigurationPart.class.isAssignableFrom(erase(type)), factory.asTypeSerializer())
+                .registerAnnotatedObjects(factory));
+    }
+
+    private static void transformLegacyConfig(ConfigurationNode node, MultiPaperConfiguration config) {
+        getAndRemove(node, "bungeecordName", value -> config.masterConnection.myName = value.getString());
+        getAndRemove(node, "multipaperMasterAddress", value -> config.masterConnection.masterAddress = value.getString());
+        getAndRemove(node, "syncJsonFiles", value -> config.syncSettings.syncJsonFiles = value.getBoolean());
+        getAndRemove(node, "advertiseToBuiltInProxy", value -> config.masterConnection.advertiseToBuiltInProxy = value.getBoolean());
+        getAndRemove(node, "syncScoreboards", value -> config.syncSettings.syncScoreboards = value.getBoolean());
+        getAndRemove(node, "logFileSyncing", value -> config.syncSettings.files.logFileSyncs = value.getBoolean());
+        getAndRemove(node, "filesToSyncOnStartup", value -> config.syncSettings.files.filesToSyncOnStartup = value.getList(String.class));
+        getAndRemove(node, "filesToSyncInRealTime", value -> config.syncSettings.files.filesToSyncInRealTime = value.getList(String.class));
+        getAndRemove(node, "filesToOnlyUploadOnServerStop", value -> config.syncSettings.files.filesToOnlyUploadOnServerStop = value.getList(String.class));
+        getAndRemove(node, "filesToNotSync", value -> config.syncSettings.files.filesToNotSync = value.getList(String.class));
+        getAndRemove(node, "ticksPerInactiveEntityTracking", value -> config.optimizations.ticksPerInactiveEntityTracking = value.getInt());
+        getAndRemove(node, "optimizations.ticksPerInactiveEntityTracking", value -> config.optimizations.ticksPerInactiveEntityTracking = value.getInt());
+        getAndRemove(node, "interServerCompressionThreshold", value -> config.peerConnection.compressionThreshold = value.getInt());
+        getAndRemove(node, "interServerConsolidationDelay", value -> config.peerConnection.consolidationDelay = value.getInt());
+        getAndRemove(node, "useLocalPlayerCountForServerIsFullKick", value -> config.syncSettings.useLocalPlayerCountForServerIsFullKick = value.getBoolean());
+        getAndRemove(node, "syncPermissions", value -> config.syncSettings.syncPermissions = value.getBoolean());
+        getAndRemove(node, "optimizations.reducePlayerPositionUpdatesInUnloadedChunks", value -> config.optimizations.reducePlayerPositionUpdatesInUnloadedChunks = value.getBoolean());
+        getAndRemove(node, "optimizations.dontSaveLightingUpdates", value -> config.optimizations.dontSaveJustForLightingUpdates = value.getBoolean());
+        getAndRemove(node, "optimizations.useFutureBasedIO", value -> config.optimizations.useEventBasedIo = value.getBoolean());
+        getAndRemove(node, "optimizations.disableRedstoneSafetySync", value -> { /* removed */ });
+    }
+
+    private static void getAndRemove(ConfigurationNode node, String key, ExceptionableConsumer<ConfigurationNode> consumer) {
+        if (System.getProperty(key) != null) {
+            try {
+                BasicConfigurationNode systemNode = BasicConfigurationNode.root();
+                systemNode.set(System.getProperty(key));
+                consumer.accept(systemNode);
+                return;
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+
+        String[] parts = key.split("\\.");
+
+        for (int i = 0; i < parts.length; i++) {
+            if (node.isMap() && node.childrenMap().containsKey(parts[i])) {
+                if (i == parts.length - 1) {
+                    try {
+                        consumer.accept(node.childrenMap().get(parts[i]));
+                        node.removeChild(parts[i]);
+                    } catch (Exception e) {
+                        e.printStackTrace();
+                    }
+                } else {
+                    node = node.childrenMap().get(parts[i]);
+                }
+            } else {
+                return;
+            }
+        }
+    }
+
+}
diff --git a/src/main/java/io/multipaper/permissions/MultiPaperCommandPermissions.java b/src/main/java/io/multipaper/permissions/MultiPaperCommandPermissions.java
new file mode 100644
index 0000000000000000000000000000000000000000..b06ea7ca929f820d8132690eb2dd37f40ba47de1
--- /dev/null
+++ b/src/main/java/io/multipaper/permissions/MultiPaperCommandPermissions.java
@@ -0,0 +1,17 @@
+package io.multipaper.permissions;
+
+import org.bukkit.permissions.Permission;
+import org.bukkit.util.permissions.DefaultPermissions;
+import org.jetbrains.annotations.NotNull;
+
+public class MultiPaperCommandPermissions {
+    private static final String ROOT = "multipaper.command";
+    private static final String PREFIX = ROOT + ".";
+
+    public static void registerPermissions(@NotNull Permission parent) {
+        Permission commands = DefaultPermissions.registerPermission(ROOT, "Gives the user the ability to use all MultiPaper commands", parent);
+
+
+        commands.recalculatePermissibles();
+    }
+}
diff --git a/src/main/java/io/multipaper/permissions/MultiPaperPermissions.java b/src/main/java/io/multipaper/permissions/MultiPaperPermissions.java
new file mode 100644
index 0000000000000000000000000000000000000000..1b9cdbe6ffe6a8162954f5645be34cc56708bbcf
--- /dev/null
+++ b/src/main/java/io/multipaper/permissions/MultiPaperPermissions.java
@@ -0,0 +1,16 @@
+package io.multipaper.permissions;
+
+import org.bukkit.permissions.Permission;
+import org.bukkit.util.permissions.DefaultPermissions;
+
+public class MultiPaperPermissions {
+    private static final String ROOT = "multipaper";
+
+    public static void registerCorePermissions() {
+        Permission parent = DefaultPermissions.registerPermission(ROOT, "Gives the user the ability to use all MultiPaper utilities and commands");
+
+        MultiPaperCommandPermissions.registerPermissions(parent);
+
+        parent.recalculatePermissibles();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Main.java b/src/main/java/net/minecraft/server/Main.java
index a7ffbbfd2a9fdeae0953ec8753ce48e93ccce086..e15a4d53f0eb5382b5f0ea56c1e019a82879e0d0 100644
--- a/src/main/java/net/minecraft/server/Main.java
+++ b/src/main/java/net/minecraft/server/Main.java
@@ -1,6 +1,5 @@
 package net.minecraft.server;
 
-import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.Dynamic;
@@ -16,13 +15,10 @@ import java.nio.file.Paths;
 import java.util.Optional;
 import java.util.function.BooleanSupplier;
 import javax.annotation.Nullable;
-import joptsimple.OptionParser;
+
+import io.multipaper.config.MultiPaperConfigurationLoader;
 import joptsimple.OptionSet;
-import joptsimple.OptionSpec;
-import joptsimple.util.PathConverter;
-import joptsimple.util.PathProperties;
 import net.minecraft.CrashReport;
-import net.minecraft.DefaultUncaughtExceptionHandler;
 import net.minecraft.Util;
 import net.minecraft.commands.Commands;
 import net.minecraft.core.Registry;
@@ -68,8 +64,8 @@ import net.minecraft.SharedConstants;
 import org.bukkit.configuration.file.YamlConfiguration;
 // CraftBukkit end
 
-import io.multipaper.shreddedpaper.config.ShreddedPaperConfiguration;
 import io.multipaper.shreddedpaper.config.ShreddedPaperConfigurationLoader;
+import io.multipaper.config.MultiPaperConfiguration;
 
 public class Main {
 
@@ -122,6 +118,9 @@ public class Main {
             }
 
             ShreddedPaperConfigurationLoader.init((File) optionset.valueOf("shreddedpaper-settings")); // ShreddedPaper
+            MultiPaperConfigurationLoader.init((File) optionset.valueOf("multipaper-settings")); // MultiPaper
+            System.setProperty("multipaper.master-connection.my-name", MultiPaperConfiguration.get().masterConnection.myName); // MultiPaper - remember this property even after config reloads
+
 
             // Purpur start - load config files early
             org.bukkit.configuration.file.YamlConfiguration purpurConfiguration = io.papermc.paper.configuration.PaperConfigurations.loadLegacyConfigFile((File) optionset.valueOf("purpur-settings"));
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 8ff1f92bf02a510299c0332a9d01c54a387adb5a..c2984000a35d536c179954de502abea34338f7ad 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -259,6 +259,7 @@ import org.yaml.snakeyaml.constructor.SafeConstructor;
 import org.yaml.snakeyaml.error.MarkedYAMLException;
 
 import net.md_5.bungee.api.chat.BaseComponent; // Spigot
+import io.multipaper.permissions.MultiPaperPermissions;
 import io.multipaper.shreddedpaper.permissions.ShreddedPaperPermissions;
 import io.multipaper.shreddedpaper.region.ShreddedPaperRegionSchedulerApiImpl;
 
@@ -580,6 +581,7 @@ public final class CraftServer implements Server {
             DefaultPermissions.registerCorePermissions();
             CraftDefaultPermissions.registerCorePermissions();
             ShreddedPaperPermissions.registerCorePermissions(); // ShreddedPaper
+            MultiPaperPermissions.registerCorePermissions(); // MultiPaper
             if (!io.papermc.paper.configuration.GlobalConfiguration.get().misc.loadPermissionsYmlBeforePlugins) this.loadCustomPermissions(); // Paper
             this.helpMap.initializeCommands();
             this.syncCommands();
diff --git a/src/main/java/org/bukkit/craftbukkit/Main.java b/src/main/java/org/bukkit/craftbukkit/Main.java
index 41f00f5af479fd48f1e67150c4cfee3049c7feb9..0518271207e7ae74bcef96cc3192e8be4dd6cf37 100644
--- a/src/main/java/org/bukkit/craftbukkit/Main.java
+++ b/src/main/java/org/bukkit/craftbukkit/Main.java
@@ -192,6 +192,14 @@ public class Main {
                         .describedAs("Yml file");
                 // ShreddedPaper end
 
+                // MultiPaper start
+                acceptsAll(asList("multipaper", "multipaper-settings"), "File for multipaper settings")
+                        .withRequiredArg()
+                        .ofType(File.class)
+                        .defaultsTo(new File("multipaper.yml"))
+                        .describedAs("Yml file");
+                // MultiPaper end
+
                 // Paper start
                 acceptsAll(asList("server-name"), "Name of the server")
                         .withRequiredArg()

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Fri, 4 Mar 2022 20:33:33 +1000
Subject: [PATCH] MultiPaper config file


diff --git a/src/main/java/net/minecraft/server/Main.java b/src/main/java/net/minecraft/server/Main.java
index 0f7d6da8685716604f0749d4f5b60730a44cde73..c2dc50007572dc4a62830e36531131032d32b1a7 100644
--- a/src/main/java/net/minecraft/server/Main.java
+++ b/src/main/java/net/minecraft/server/Main.java
@@ -23,7 +23,6 @@ import joptsimple.util.PathConverter;
 import joptsimple.util.PathProperties;
 import net.minecraft.CrashReport;
 import net.minecraft.DefaultUncaughtExceptionHandler;
-import net.minecraft.SharedConstants;
 import net.minecraft.Util;
 import net.minecraft.commands.Commands;
 import net.minecraft.core.Registry;
@@ -69,6 +68,9 @@ import net.minecraft.SharedConstants;
 import org.bukkit.configuration.file.YamlConfiguration;
 // CraftBukkit end
 
+import puregero.multipaper.config.MultiPaperConfiguration;
+import puregero.multipaper.config.MultiPaperConfigurationLoader;
+
 public class Main {
 
     private static final Logger LOGGER = LogUtils.getLogger();
@@ -119,6 +121,8 @@ public class Main {
                 JvmProfiler.INSTANCE.start(Environment.SERVER);
             }
 
+            MultiPaperConfigurationLoader.init((File) optionset.valueOf("multipaper-settings")); // MultiPaper
+
             // Purpur start - load config files early
             org.bukkit.configuration.file.YamlConfiguration purpurConfiguration = io.papermc.paper.configuration.PaperConfigurations.loadLegacyConfigFile((File) optionset.valueOf("purpur-settings"));
             org.purpurmc.purpur.PurpurConfig.clampEnchantLevels = purpurConfiguration.getBoolean("settings.enchantment.clamp-levels");
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 6e78500a6265b0192095379704b1d661ef56ba32..5abd5ced015be7de740d504b5c0b0620822f22ac 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -259,6 +259,7 @@ import org.yaml.snakeyaml.constructor.SafeConstructor;
 import org.yaml.snakeyaml.error.MarkedYAMLException;
 
 import net.md_5.bungee.api.chat.BaseComponent; // Spigot
+import puregero.multipaper.permissions.MultiPaperPermissions;
 
 import javax.annotation.Nullable; // Paper
 import javax.annotation.Nonnull; // Paper
@@ -577,6 +578,7 @@ public final class CraftServer implements Server {
             this.commandMap.registerServerAliases();
             DefaultPermissions.registerCorePermissions();
             CraftDefaultPermissions.registerCorePermissions();
+            MultiPaperPermissions.registerCorePermissions(); // MultiPaper
             if (!io.papermc.paper.configuration.GlobalConfiguration.get().misc.loadPermissionsYmlBeforePlugins) this.loadCustomPermissions(); // Paper
             this.helpMap.initializeCommands();
             this.syncCommands();
diff --git a/src/main/java/org/bukkit/craftbukkit/Main.java b/src/main/java/org/bukkit/craftbukkit/Main.java
index 6d8e9cf4ee496b8748654e792ce438f512c3d946..7356f7eebb51832c3455eab749ed27201bb741d2 100644
--- a/src/main/java/org/bukkit/craftbukkit/Main.java
+++ b/src/main/java/org/bukkit/craftbukkit/Main.java
@@ -184,6 +184,14 @@ public class Main {
                     .describedAs("Yml file");
                 // Purpur end
 
+                // MultiPaper start
+                acceptsAll(asList("multipaper", "multipaper-settings"), "File for multipaper settings")
+                        .withRequiredArg()
+                        .ofType(File.class)
+                        .defaultsTo(new File("multipaper.yml"))
+                        .describedAs("Yml file");
+                // MultiPaper end
+
                 // Paper start
                 acceptsAll(asList("server-name"), "Name of the server")
                         .withRequiredArg()
diff --git a/src/main/java/puregero/multipaper/config/ExceptionableConsumer.java b/src/main/java/puregero/multipaper/config/ExceptionableConsumer.java
new file mode 100644
index 0000000000000000000000000000000000000000..7cdf20efd4f220f55d7b86abce19e84f4512191e
--- /dev/null
+++ b/src/main/java/puregero/multipaper/config/ExceptionableConsumer.java
@@ -0,0 +1,8 @@
+package puregero.multipaper.config;
+
+@FunctionalInterface
+public interface ExceptionableConsumer<T> {
+
+    void accept(T t) throws Exception;
+
+}
diff --git a/src/main/java/puregero/multipaper/config/MultiPaperConfiguration.java b/src/main/java/puregero/multipaper/config/MultiPaperConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..a198aadad3acdf431321e05f62b392d408246a4c
--- /dev/null
+++ b/src/main/java/puregero/multipaper/config/MultiPaperConfiguration.java
@@ -0,0 +1,67 @@
+package puregero.multipaper.config;
+
+import io.papermc.paper.configuration.ConfigurationPart;
+import org.spongepowered.configurate.objectmapping.meta.Comment;
+
+import java.util.List;
+
+@SuppressWarnings({ "InnerClassMayBeStatic" })
+public class MultiPaperConfiguration extends ConfigurationPart {
+
+    public static final String HEADER = """
+            This is the main configuration file for MultiPaper.
+            There's quite alot to configure. Read the docs for more information.
+
+            Docs: https://github.com/MultiPaper/MultiPaper/blob/main/MULTIPAPER_YAML.md\s
+            """;
+
+    private static MultiPaperConfiguration instance;
+
+    public static MultiPaperConfiguration get() {
+        return instance;
+    }
+
+    static void set(MultiPaperConfiguration instance) {
+        MultiPaperConfiguration.instance = instance;
+    }
+
+    public VerticalScaling verticalScaling;
+
+    public class VerticalScaling extends ConfigurationPart {
+
+        public int threadCount = -1;
+        public int regionSize = 8;
+        public boolean runUnsupportedPluginsInSync = true;
+
+    }
+
+    public HorizontalScaling horizontalScaling;
+
+    public class HorizontalScaling extends ConfigurationPart {
+
+        public DatabaseConnection databaseConnection;
+
+        public class DatabaseConnection extends ConfigurationPart {
+
+            public String databaseAddress = "";
+
+        }
+
+        public SyncSettings syncSettings;
+
+        public class SyncSettings extends ConfigurationPart {
+
+            public Files files;
+
+            public class Files extends ConfigurationPart {
+                public List<String> filesToNotSync = List.of("plugins/bStats");
+                public List<String> filesToOnlyUploadOnServerStop = List.of("plugins/MyPluginDirectory/my_big_database.db");
+                public List<String> filesToSyncInRealTime = List.of("plugins/MyPluginDirectory/userdata");
+                public List<String> filesToSyncOnStartup = List.of("myconfigfile.yml", "plugins/MyPlugin.jar");
+                public boolean logFileSyncs = true;
+            }
+        }
+    }
+
+
+}
diff --git a/src/main/java/puregero/multipaper/config/MultiPaperConfigurationLoader.java b/src/main/java/puregero/multipaper/config/MultiPaperConfigurationLoader.java
new file mode 100644
index 0000000000000000000000000000000000000000..903f47c87045334f05fae22c48d8dad05897dd08
--- /dev/null
+++ b/src/main/java/puregero/multipaper/config/MultiPaperConfigurationLoader.java
@@ -0,0 +1,140 @@
+package puregero.multipaper.config;
+
+import io.papermc.paper.configuration.ConfigurationLoaders;
+import io.papermc.paper.configuration.ConfigurationPart;
+import io.papermc.paper.configuration.constraint.Constraint;
+import io.papermc.paper.configuration.constraint.Constraints;
+import io.papermc.paper.configuration.mapping.InnerClassFieldDiscoverer;
+import org.spongepowered.configurate.BasicConfigurationNode;
+import org.spongepowered.configurate.CommentedConfigurationNode;
+import org.spongepowered.configurate.ConfigurateException;
+import org.spongepowered.configurate.ConfigurationNode;
+import org.spongepowered.configurate.ConfigurationOptions;
+import org.spongepowered.configurate.objectmapping.ObjectMapper;
+import org.spongepowered.configurate.serialize.SerializationException;
+import org.spongepowered.configurate.yaml.YamlConfigurationLoader;
+
+import java.io.File;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.Map;
+import java.util.function.UnaryOperator;
+
+import static io.leangen.geantyref.GenericTypeReflector.erase;
+
+public class MultiPaperConfigurationLoader {
+
+    public static void init(File file) {
+        try {
+            YamlConfigurationLoader.Builder loaderBuilder = ConfigurationLoaders.naturallySorted();
+            loaderBuilder.defaultOptions(options -> options.header(MultiPaperConfiguration.HEADER));
+
+            Path configFile = file.toPath();
+            YamlConfigurationLoader loader = loaderBuilder
+                    .defaultOptions(applyObjectMapperFactory(createObjectMapper().build()))
+                    .path(configFile)
+                    .build();
+            ConfigurationNode node;
+            if (Files.exists(configFile)) {
+                node = loader.load();
+            } else {
+                node = CommentedConfigurationNode.root(loader.defaultOptions());
+            }
+
+            String before = node.toString();
+            setFromProperties(node);
+
+            MultiPaperConfiguration instance = node.require(MultiPaperConfiguration.class);
+            transformLegacyConfig(node, instance);
+
+            for (Object key : node.childrenMap().keySet()) {
+                node.removeChild(key);
+            }
+
+            node.set(instance);
+
+            if (!node.toString().equals(before)) {
+                loader.save(node);
+            }
+
+            MultiPaperConfiguration.set(instance);
+        } catch (ConfigurateException e) {
+            throw new RuntimeException("Could not load multipaper.yml", e);
+        }
+    }
+
+    private static void setFromProperties(ConfigurationNode node) {
+        for (Map.Entry<Object, Object> property : System.getProperties().entrySet()) {
+            if (property.getKey().toString().startsWith("multipaper.")) {
+                String key = property.getKey().toString().substring("multipaper.".length());
+                try {
+                    node.node((Object[]) key.split("\\.")).set(property.getValue());
+                } catch (SerializationException e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+    }
+
+    private static ObjectMapper.Factory.Builder createObjectMapper() {
+        return ObjectMapper.factoryBuilder()
+                .addConstraint(Constraint.class, new Constraint.Factory())
+                .addConstraint(Constraints.Min.class, Number.class, new Constraints.Min.Factory())
+                .addDiscoverer(InnerClassFieldDiscoverer.globalConfig());
+    }
+
+    private static UnaryOperator<ConfigurationOptions> applyObjectMapperFactory(final ObjectMapper.Factory factory) {
+        return options -> options.serializers(builder -> builder
+                .register(type -> ConfigurationPart.class.isAssignableFrom(erase(type)), factory.asTypeSerializer())
+                .registerAnnotatedObjects(factory));
+    }
+
+    private static void transformLegacyConfig(ConfigurationNode node, MultiPaperConfiguration config) {
+        getAndRemove(node, "master-connection.master-address", value -> config.horizontalScaling.databaseConnection.databaseAddress = value.getString());
+        getAndRemove(node, "sync-settings.files.log-file-syncs", value -> config.horizontalScaling.syncSettings.files.logFileSyncs = value.getBoolean());
+        getAndRemove(node, "sync-settings.files.files-to-sync-on-startup", value -> config.horizontalScaling.syncSettings.files.filesToSyncOnStartup = value.getList(String.class));
+        getAndRemove(node, "sync-settings.files.files-to-sync-in-real-time", value -> config.horizontalScaling.syncSettings.files.filesToSyncInRealTime = value.getList(String.class));
+        getAndRemove(node, "sync-settings.files.files-to-only-upload-on-server-stop", value -> config.horizontalScaling.syncSettings.files.filesToOnlyUploadOnServerStop = value.getList(String.class));
+        getAndRemove(node, "sync-settings.files.files-to-not-sync", value -> config.horizontalScaling.syncSettings.files.filesToNotSync = value.getList(String.class));
+
+        getAndRemove(node, "multipaperMasterAddress", value -> config.horizontalScaling.databaseConnection.databaseAddress = value.getString());
+        getAndRemove(node, "logFileSyncing", value -> config.horizontalScaling.syncSettings.files.logFileSyncs = value.getBoolean());
+        getAndRemove(node, "filesToSyncOnStartup", value -> config.horizontalScaling.syncSettings.files.filesToSyncOnStartup = value.getList(String.class));
+        getAndRemove(node, "filesToSyncInRealTime", value -> config.horizontalScaling.syncSettings.files.filesToSyncInRealTime = value.getList(String.class));
+        getAndRemove(node, "filesToOnlyUploadOnServerStop", value -> config.horizontalScaling.syncSettings.files.filesToOnlyUploadOnServerStop = value.getList(String.class));
+        getAndRemove(node, "filesToNotSync", value -> config.horizontalScaling.syncSettings.files.filesToNotSync = value.getList(String.class));
+    }
+
+    private static void getAndRemove(ConfigurationNode node, String key, ExceptionableConsumer<ConfigurationNode> consumer) {
+        if (System.getProperty(key) != null) {
+            try {
+                BasicConfigurationNode systemNode = BasicConfigurationNode.root();
+                systemNode.set(System.getProperty(key));
+                consumer.accept(systemNode);
+                return;
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+
+        String[] parts = key.split("\\.");
+
+        for (int i = 0; i < parts.length; i++) {
+            if (node.isMap() && node.childrenMap().containsKey(parts[i])) {
+                if (i == parts.length - 1) {
+                    try {
+                        consumer.accept(node.childrenMap().get(parts[i]));
+                        node.removeChild(parts[i]);
+                    } catch (Exception e) {
+                        e.printStackTrace();
+                    }
+                } else {
+                    node = node.childrenMap().get(parts[i]);
+                }
+            } else {
+                return;
+            }
+        }
+    }
+
+}
diff --git a/src/main/java/puregero/multipaper/permissions/MultiPaperCommandPermissions.java b/src/main/java/puregero/multipaper/permissions/MultiPaperCommandPermissions.java
new file mode 100644
index 0000000000000000000000000000000000000000..f7d9a1538ec842e453e5add3f9e33f8c43bfa3d2
--- /dev/null
+++ b/src/main/java/puregero/multipaper/permissions/MultiPaperCommandPermissions.java
@@ -0,0 +1,17 @@
+package puregero.multipaper.permissions;
+
+import org.bukkit.permissions.Permission;
+import org.bukkit.util.permissions.DefaultPermissions;
+import org.jetbrains.annotations.NotNull;
+
+public class MultiPaperCommandPermissions {
+    private static final String ROOT = "multipaper.command";
+    private static final String PREFIX = ROOT + ".";
+
+    public static void registerPermissions(@NotNull Permission parent) {
+        Permission commands = DefaultPermissions.registerPermission(ROOT, "Gives the user the ability to use all MultiPaper commands", parent);
+
+
+        commands.recalculatePermissibles();
+    }
+}
diff --git a/src/main/java/puregero/multipaper/permissions/MultiPaperPermissions.java b/src/main/java/puregero/multipaper/permissions/MultiPaperPermissions.java
new file mode 100644
index 0000000000000000000000000000000000000000..91b2e3564d7c737b2006f8c2860ab43846637384
--- /dev/null
+++ b/src/main/java/puregero/multipaper/permissions/MultiPaperPermissions.java
@@ -0,0 +1,16 @@
+package puregero.multipaper.permissions;
+
+import org.bukkit.permissions.Permission;
+import org.bukkit.util.permissions.DefaultPermissions;
+
+public class MultiPaperPermissions {
+    private static final String ROOT = "multipaper";
+
+    public static void registerCorePermissions() {
+        Permission parent = DefaultPermissions.registerPermission(ROOT, "Gives the user the ability to use all MultiPaper utilities and commands");
+
+        MultiPaperCommandPermissions.registerPermissions(parent);
+
+        parent.recalculatePermissibles();
+    }
+}
